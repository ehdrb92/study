AWS Lambda 함수를 사용할 때 pandas, numpy 등 외부 라이브러리를 사용하는 경우 두 가지 방식 중 하나를 택할 수 있다.

- 프로젝트의 외부 라이브러리를 함께 zip 압축하여 배포한다.
- layer를 만들고 함수에 해당 layer를 추가한다.

두 방식은 각각 다른 장단점을 가진다.

## 한꺼번에 zip으로 배포

- 장점
  - 설정이 단순하고 직관적이이다. 코드와 의존성을 한 번에 관리할 수 있다.
  - 다른 Lambda 함수와 의존성 충돌 걱정이 없다. 함수마다 독립적인 환경을 가진다.
  - 배포 단위가 self-contained라 디버깅이 쉽다.
- 단점
  - 동일한 라이브러리를 사용하는 함수가 여럿일 경우, 매번 중복 포함해야 해서 패키지 크기가 커집니다.
  - 공통 라이브러리에 업데이트가 필요할 때 모든 함수를 개별 재배포해야 한다.
  - 패키지가 커지면 Lambda 콘솔에서 인라인 코드 편집이 불가능해진다. (압축 해제 기준 250MB 제한)

## Lambda Layer 사용

- 장점
  - 여러 함수가 같은 Layer를 공유할 수 있어 중복 제거 및 패키지 경량화가 가능하다.
  - 라이브러리 업데이트 시 Layer만 새 버전으로 교체하면 연결된 함수들에 일괄 적용할 수 있다.
  - 함수 코드 자체가 작아져 콘솔 인라인 편집이 가능해질 수 있다.
  - 최대 5개의 Layer를 함수에 추가할 수 있어 관심사 분리가 용이하다.
- 단점
  - Layer 버전 관리가 추가되어 운영 복잡도가 올라간다.
  - 여러 함수가 같은 Layer를 공유하므로, Layer 변경 시 의도치 않은 영향을 줄 수 있다.
  - Layer도 포함하여 압축 해제 기준 250MB 제한은 동일하게 적용된다.
  - Lambda 콘솔 또는 CLI/IaC 도구에서 Layer를 별도로 관리해야 하는 추가 작업이 필요하다.

## 패키지 크기와 Cold Start의 관계

일반적으로 외부 라이브러리를 함께 zip 파일로 배포할 경우 크기가 커질 확률이 매우 높다. 이는 cold start에도 어느 정도 영향이 있다. 하지만 패키지의 크기 자체가 큰 영향을 주는 것은 아니다. AWS 문서에 따르면 큰 패키지는 S3 다운로드 시간 증가, ZIP 압축 해제 오버헤드, 레이어 마운트 및 초기화 등의 요인으로 cold start 지연에 영향을 줄 수 있다고 한다.

그러나 cold start에 가장 큰 영향을 미치는 것은 패키지 크기 자체보다는, 패키지가 처음 로드될 때의 초기화(initialization) 시간이다. 사용하는 패키지 수가 많을수록 컨테이너가 이를 로드하는 데 더 오래 걸린다.

정리하면 파일의 크기가 아닌 import 해야하는 라이브러리의 수와 그 초기화 비용이다. 사실상 함수 경로에 라이브러리가 존재하던, layer로 라이브러리를 가져오던 동일한 방식으로 import를 하기 때문에 두 방식이 cold start 시간에 큰 영향을 끼칠 가능성은 낮다.

cold start는 일반적으로 전체 요청의 1% 미만에서 발생하지만, Lambda가 비활성 기간 이후 재호출되거나 빠르게 스케일 아웃해야 할 때 더 자주 발생하며, 특히 사용자 대면 API 같은 지연 시간에 민감한 애플리케이션에서 체감 응답 시간에 영향을 줄 수 있다. 결제 처리나 실시간 알림처럼 응답 속도가 SLA에 직결되는 서비스라면 꽤 치명적일 수 있다.

이에 대한 대응 수단은 다음과 같다.

- 패키지 최적화: 불필요한 의존성 제거, 사용하지 않는 파일(테스트, 문서 등) 제외
- Provisioned Concurrency: 미리 인스턴스를 warm 상태로 유지. cold start를 사실상 제거할 수 있지만, 1GB 메모리 기준 5개 인스턴스를 provisioned로 유지하면 실행 비용 외에 추가 비용이 발생한다.
- Warming 전략: CloudWatch Events 등으로 주기적으로 함수를 호출해 warm 상태를 유지하는 방법. 비용은 낮지만 완벽한 해결책은 아니다.

## layer 방식은 운영체제의 동적 링킹과 유사한가?

결론부터 말하자면 유사하지만 다르다.

유사한 부분은 동일한 라이브러리를 공유한다는 점이다. 여러 곳에서 공유 가능한 외부 의존성을 실행 코드와 분리한다는 점은 맞다. 하지만 운영체제 수준에서 동적 링킹은 공유 의존성을 메모리에 올리고 각 프로세스들이 메모리 페이지를 공유한다. 하지만 lambda의 layer는 각 함수 인스턴스마다 독립된 실행 환경에서 개별적으로 마운트된다. 메모리 공유는 없다.

또한 버전 충돌 문제의 양상이 다르다. 동적 링킹은 `DLL Hell`처럼 시스템 전역의 라이브러리 버전 충돌이 실제로 발생한다. 하지만 lambda의 layer는 함수마다 어떤 버전의 layer를 쓸지 명시적으로 지정하므로, 이 문제가 상대적으로 덜 하다.

cold start 영향도 다르다. 동적 링킹은 이미 메모리에 올라온 라이브러리를 재사용하므로 로딩이 빠르다. 하지만 lambda layer는 매번 독립된 환경에 새로 마운트되기 때문에, 이 이점이 적용되지 않는다.
