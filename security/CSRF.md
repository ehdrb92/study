CSRF(Cross-Site Request Forgery, 교차 사이트 요청 위조)

## CSRF에 대한 다른 사실

웹 보안 동격 기법 중 하나이다. 사용자가 자신도 모르게 의도치 않은 요청을 서버에 보내도록 속이는 공격이다.

처음에는 웹 브라우저의 동일 출처 정책 또한 CSRF 공격과 관련이 있다고 생각했다. 하지만 사실 CSRF 공격을 동일 출처 정책은 막지 못한다. 이유는 동일 출처 정책은 사실상 "읽기" 행위를 통제하는 것이다. 만약 악성 코드가 보내는 요청이 "단순 요청" 조건에 부합하고 서버에 데이터를 생성하거나 수정하는 부분이 있다면, 해당 작업 자체는 이루어짐으로 결국 막지 못한다.

그래서 이를 방어하기 위한 수단이 CORS가 아닌 다른 방법이 필요한 것이다.


## CSRF의 작동원리

1. 사용자가 신뢰할 수 있는 웹 사이트에 로그인하면 인증 쿠키를 받아서 브라우저에 저장하게 된다.
2. 그 상태에서 공격자가 만든 악성 웹 페이지에 접속하거나, 이메일 링크를 사용자가 클릭한다.
3. 그 페이지 안에는 사용자의 인증 쿠키가 자동으로 전송되는 요청이 숨어 있다.
4. 요청을 받은 서버는 인증 쿠키를 함께 받기 때문에 정상적인 요청이라고 인식하고 처리한다.

즉, 사용자의 인증 세션을 악용해서 공격자가 원하는 동작을 수행하게 만드는 것이다.

만약 공격자가 만든 HTML에 다음과 같은 폼이 존재한다고 가정하자.

```html
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker_account">
  <input type="hidden" name="amount" value="1000000">
</form>
<script>document.forms[0].submit();</script>
```

사용자가 로그인한 상태에서 이 페이지를 열면 자동으로 은행 서버에 송금 요청이 가게 된다.


## 어떻게 방어하는가?

- CSRF 토큰 사용: 요청 시 임의의 난수 토큰을 포함하게 하고, 서버가 이를 검증한다. 공격자는 이 토큰을 알 수 없으므로 위조 요청이 막힌다.
- Referer/Origin 헤더 검사: 요청이 올바른 출처인지 확인하여 아닐 경우 차단한다.
- 쿠키에 SameSite 속성 설정: 다른 사이트에서 자동으로 쿠키가 전송되지 않도록 제한한다.


## SamSite 옵션이란?

쿠키가 언제 브라우저에서 자동으로 전송될 지를 제어하는 보안 속성이다. 해당 속성을 별도로 설정하지 않는다면 기본적으로 모든 요청에 해당 도메인의 쿠키를 붙여서 보낸다.

옵션을 종류는 다음과 같다.

- Strict
  - 해당 사이트에서 직접 요청을 보낼 때만 쿠키가 전송됩니다.
  - 다른 도메인에서 링크 클릭을 해도 자동 로그인 같은 쿠키가 전송되지 않음.
  - 보안은 가장 강하지만, UX(사용성)는 불편할 수 있습니다.
- Lax (기본값, 대부분 브라우저에서 기본 적용)
  - "안전한" HTTP 메서드(GET) 요청에 대해서는 쿠키를 보냅니다.
  - 예를 들어, 사용자가 구글 검색 결과에서 네이버 블로그를 클릭하면 세션 쿠키는 전송됩니다.
  - 그러나 POST 같은 상태 변화를 일으키는 요청에는 쿠키가 자동으로 안 붙습니다.
  - 보안과 사용성의 균형을 맞추려는 옵션입니다.
- None
  - 제약 없이 모든 요청에 쿠키를 붙입니다.
  - 단, 이 경우 반드시 Secure 속성과 함께 HTTPS에서만 동작해야 합니다.
  - 크로스 사이트 요청에도 쿠키가 붙으므로, CSRF 위험이 가장 커집니다.


## Secure 속성

- 쿠키에 Secure 속성이 붙는다면, 쿠키는 HTTPS 연결에서만 전송된다.
- 평문이 노출될 수 있는 HTTP 요청에는 절대 포함시키지 않아 보안 위험을 줄일 수 있다.

```javascript
Set-Cookie: sessionid=abc123; Secure; HttpOnly; SameSite=Lax
```