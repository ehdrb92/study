로그인(인증) API 사용 시 비즈니스 로직의 문제로 해커의 타이밍 공격 표적이 될 수 있다. 일반적으로 잘못된 로직의 코드 예시는 다음과 같다.

```python
import hashlib
from database import get_user_by_username  # 가상의 DB 조회 함수

def login(username: str, password: str):
    user = get_user_by_username(username)  # ~1ms
    
    # 사용자가 없으면 즉시 반환 → 응답 빠름
    if user is None:
        return {"error": "Invalid credentials"}
    
    # 사용자가 있으면 해시 비교 수행 → 응답 느림 (~100ms)
    hashed_input = hashlib.sha256(password.encode()).hexdigest()
    if hashed_input != user["password_hash"]:
        return {"error": "Invalid credentials"}
    
    return {"token": generate_token(user)}
```

데이터베이스 쿼리 시간 대비 일반적으로 해시 함수를 통한 비교 알고리즘의 수행 시간은 10 ~ 100배 수준으로 차이난다. 그래서 해커는 응답 시간의 차이로 사용자의 존재 여부를 확인하는 공격을 수행할 수 있다. 이러한 문제를 방지하기 위해서 다음과 같은 방어 기법이 있다.

```python
import hashlib
import hmac
import bcrypt

# 사용자가 없을 때도 해시 비교를 수행할 더미 해시
DUMMY_HASH = bcrypt.hashpw(b"dummy_password", bcrypt.gensalt())

def login(username: str, password: str):
    user = get_user_by_username(username)
    
    if user is None:
        # 사용자가 없어도 동일한 비용의 해시 비교 수행
        bcrypt.checkpw(password.encode(), DUMMY_HASH)
        return {"error": "Invalid credentials"}
    
    if not bcrypt.checkpw(password.encode(), user["password_hash"]):
        return {"error": "Invalid credentials"}
    
    return {"token": generate_token(user)}
```

사용자가 존재하는지 여부와 관계없이 해시 함수는 무조건 수행하는 것이다. 대신 사용자가 존재하지 않을 때의 비교는 더미 데이터로 수행한다. 이렇게 하면 사용자 존재 여부와 상관없이 거의 동일한 응답 시간으로 추측을 불가능하게 만든다.
