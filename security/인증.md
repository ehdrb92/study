백엔드 개발자 관점에서 신경써야할 보안 개념들에 대해서 정리해보자. 보안에서 일반적으로 `인증`, `인가` 두 가지 개념에 대해서 생각해야한다.

먼저 인증을 위한 수단에는 무엇이 있는가?

## 세션 쿠키(Session Cookie)

세션은 사용자가 로그인하면 서버가 세션 ID를 생성하고, 해당 ID를 서버 메모리에 저장한다. 클라이언트는 서버에 API 요청을 할 때마다 브라우저 쿠키에 해당 세션 ID를 담아서 서버로 전달한다. 굉장히 단순하고 구현이 쉽지만 그만큼 탈취 공격에 취약하고, 서버 확장 시 세션 동기화 문제가 존재한다.

## JWT(Json Web Token)

JSON 객체 형태로 당사자간 정보를 안전하게 전송하기위한 토큰이다. 토큰 정보는 디지털 서명이 되어있기 때문에 검증 및 신뢰가 가능하다. 비밀 키 또는 RSA/ECDSA를 활용한 공개/개인 키 쌍으로 서명이 가능하다. 서명된 토큰은 포함된 클레임의 무결성을 검증할 수 있고, 암호화된 토큰은 클레임을 다른 당사자로부터 숨길 수 있다.

JWT는 다음과 같은 구조로 된다.

`<header>.<payload>.<signature>`

- Header: alg(서명 알고리즘), typ, kid 등
- Payload: 등록된 표준 클레임과 커스텀 클레임.
  - 표준 클레임 예시: iss(발급자), sub(주체), aud(대상자), exp(만료), iat(발급 시각), jti(토큰 ID)
- Signature: 서명 (sign( base64url(header) + "." + base64url(payload) ))

점으로 구분된 전부 `Base64URL`로 인코딩 된다.

JWT는 최대 장점 중 하나는 `stateless`이다. 하지만 실무에서는 보통 JWT와 관련된 정보를 별도의 캐시에 저장한다. 이유는 로그아웃이나 토큰 탈취에 의한 인증되지 않은 사용자의 사용에 대한 보안 문제를 해결하기 위해서이다.

### JWT 토큰 검증

- 알고리즘 강제: 서버가 기대하는 알고리즘을 고정하고, 토큰 헤더의 `alg` 값을 그대로 믿어서는 안된다.
- 클레임 엄격 검증: 
  - `exp`, `nbf`, `iat` 시간확인
  - `iss`, `aud` 필수 검증
  - 필요한 경우 `jti` 사용 (블랙리스트)
- 키 관리(JWKS) & 회전:
  - 헤더 `kid`로 JWKS에서 맞는 공개키 선택
  - 키 주기적 교체
- JWE가 필요한 경우: 토큰 Payload에 민감정보가 포함된다면, 서명(JWS) + 암호화(JWE)를 사용

### JWT 발급자 확인 사항

- Access Token, Refresh Token 분리: 엑세스 토큰은 수 분 ~ 수 십분, 리프레시 토큰은 일 ~ 주 단위 + 회전으로 재사용 탐지
- 토큰 철회 및 무효화 전략: 필요 시 `jti` 또는 토큰 버전을 사용자 데이터에 저장하여 서버 측 블랙리스트로 조기 무효화
- 최소 클레임: 불필요한 개인정보 혹은 권한목록을 싣지 말것. Payload는 누구나 디코드하여 확인가능.

### JWT 클라이언트 측 확인 사항

- 전송은 무조건 HTTPS를 사용. URL 쿼리 매개변수로 전달 금지
- 저장위치
  - 브라우저라면 HttpOnly + Secure + SameSite 쿠키를 1순위로 고려(XSS로 부터 읽기 방지, CSRF는 SameSite/토큰화로 대응)
  - 로컬 스토리지는 XSS에 읽히므로 높은 보안 요구에는 지양
- CORS/보안 헤더: 적절한 CORS 정책과 `Content-Security-Policy`로 XSS 노출면 줄이기

## API Key 기반 인증

가장 단순한 방식으로, 서버에서 고유한 문자열을 HTTP 헤더나 쿼리 매개변수 등에 감아 보내는 방식이다.

- 복잡한 토큰 핸들링이나 인코딩이 필요없다.
- 특정 사용자의 세밀한 권한 제어에는 적합하지 않다.
- 일반적으로 서버 간 통신, 공공 데이터 API 등에 적당하다.

## OpenID Connect(OIDC)

OAuth2의 인가 규격에 인증 계층을 추가한 방식

- ID Token: OAuth2의 Access Token 외에 사용자의 정보를 담은 ID Token(JWT)을 추가로 발행
- 표준화된 사용자 정보: 사용자의 이름, 이메일 등을 가져오는 방식이 규격화되어 있어 여러 서비스 간의 SSO(Single Sign-On) 구현에 유리
- 소셜 로그인 연동, 기업 내 여러 서비스 통합 인증에 유리