민감한 정보의 데이터를 암호화하는 방법에 대해서 알아보자.

## 단방향 암호화

단방향 암호화는 데이터를 복호화할 수 없는 암호화 방식이다. 해시 함수를 이용해서 데이터를 해시 값으로 변환한다. 일반적으로 사용되는 알고리즘은 SHA-256, MD5, BCrypt 등이 있다.

단방향 암호화는 로그인 암호와 같은 문자열을 암호화하는데 주로 사용한다. 하지만 실제 암호화 로직은 이진 데이터를 기준으로 동작하기 때문에 문자열을 인코딩하는 것이 사전되어야 한다.

### 충돌 저항성

해시 함수는 원본 데이터의 길이에 상관없이 정해진 길이의 해시 값을 생성한다. 결과의 길이가 제한되기 때문에 원본 데이터가 다름에도 아주 낮은 확률로 같은 해시 결과가 나올 수 있다. 그래서 사전에 서로 다른 데이터에 대해 최대한 다른 해시 값을 가지도록 하는 해시 알고리즘을 선택하는 것이 중요하다. 동일한 해시 값을 갖는 데이터를 찾기 어려우면, 해당 해시 함수는 충돌 저항성을 갖는다고 한다.

일반적으로 해시 함수의 생성 결과가 길수록 충돌 저항성이 높다. 예를 들어 SHA-256과 SHA-512의 해시 값은 각각 256비트, 512비트이므로 SHA-512가 충돌 저항성이 더 높다.

### Salt를 이용한 보안 강화

같은 해시 알고리즘을 사용한다면 동일한 원본 데이터에 대해 항상 동일한 해시 값이 생성된다. 이 특성 때문에 해시 값으로 원본 유추가 가능하게 된다. 해커는 다양한 문자열 조합에 대한 해시 값을 미리 계산해서 테이블로 정리한다. 이를 레인보우 테이블이라고 한다. 해커는 탈취한 해시 값과 레인보우 테이블의 참조로 해킹이 가능하다.

이러한 보안 문제를 방지하기 위해 솔트를 사용한다. 솔트는 원본 데이터에 추가되는 임의의 값이다. 해시 함수에 원본을 투입하기 전 솔트 값을 더해준 뒤 해시 함수를 동작시키면, 솔트 값을 모르는한 해시 값만으로 원본 데이터를 찾는 것은 불가능에 가깝다.

## 양방향 암호화

양방향 암호화는 암호화와 복호화가 모두 가능하다. 서버에 접속할 때 사용하는 SSH 프로토콜, API 호출 시 사용하는 HTTPS와 같은 데이터 송수신 상황에서 주로 사용된다. 대표적인 양방향 암호화 알고리즘으로는 AES, RSA가 있다.

양방향 암호화는 키를 사용하여 암호화와 복호화를 한다. 같은 알고리즘에 원본 데이터라도 단방향 암호화와 다르게 키가 다르면 데이터가 달라진다.

양방향 암호화는 또한 내부적으로 `대칭 키`, `비대칭 키` 방식으로 나뉜다.

### 대칭 키 방식

대칭 키는 암호화와 복호화 시 동일한 키를 사용하는 방식이다. 이 방식은 키가 유출되면 누구나 암호화된 데이터를 복호화할 수 있기 때문에 키의 보안이 매우 중요하다.

### 비대칭 키 방식

비대칭 키는 암호화와 복호화에 서로 다른 키를 사용하는 방식이다. 공개 키와 개인 키를 생성한다. 키 소유주는 공개 키와 개인 키 쌍을 생성한다. 그리고 자신에게 데이터를 송신할 대상 모두에게 공개 키를 제공한다. 공개 키를 받은 이는 해당 키로 보낼 데이터를 암호화한다. 그리고 데이터를 받은 키 소유주는 개인 키로 암호화된 데이터를 복호화하여 확인 가능하다.

키 소유주의 디스크에 직접 접근하여 개인 키를 탈취하지 않는 이상 보안에 문제가 생길 수 없다.

물론 개인 키로 암호화하고 공개 키로 복호화하는 것도 가능하다. 보통 신원 확인이나 서명과 같은 인증 목적으로 사용된다. 대표적으로 SSH 서버는 접속할 서버에 공개 키를 등록하고, 클라이언트는 개인 키를 이용해서 인증한다.

## HMAC을 이용한 데이터 검증

클라이언트가 서버에 데이터를 전송했을 때 서버는 해당 데이터의 위변조되지 않았다는 것을 확인할 수단이 필요하다. 이때 대표적으로 사용하는 방법이 HMAC(Hash-based Message Authentication Code)이다. 메시지의 무결성과 인증을 보장하기 위해 사용하는 암호화 기술이다. HMAC은 해시 함수와 비밀 키를 이용해서 다음 2가지를 보장한다.

- 메시지 무결성: 메시지가 중간에 위변조되지 않음
- 인증: 메시지 발신자를 인증할 수 있음

메시지 발신자와 수신자는 둘만 가지는 비밀 키를 공유한다. 이 비밀 키는 절대 외부에 노출되어서는 안된다.

메시지 발신자는 메시지를 비밀 키로 해싱하여 MAC(Message Authentication Code)를 생성하여 메시지 원본과 함께 서버로 전송한다. 서버는 메시지를 본인이 가진 비밀 키로 해싱하여 MAC를 생성하고, 발신자가 보낸 MAC와 비교하여 같은지 확인하는 방법으로 메시지의 무결성을 확인한다.

HMAC은 일반적인 웹(브라우저 프론트엔드 <-> 백엔드) 시나리오에서는 사용되지 않는다. 왜냐하면 비밀 키를 JS 소스에 저장해야하는데 이는 브라우저에서 누구나 확인할 수 있기 때문에 비밀 키 추출이 너무 간단하기 때문이다.

HMAC이 주로 쓰이는 구조는 백엔드 <-> 백엔드간의 통신 혹은 공식 모바일 앱 <-> 서버 구조에서 사용된다. 배포되는 앱 혹은 백엔드 서버에 포함되는 비밀 키는 쉽게 탈취 당하지는 않기 때문이다. 하지만 탈취 가능성이 존재하지 않는 것은 아니기 때문에 이 또한 짧은 수명의 토큰과 함께 사용한다.

### HMAC과 HTTPS

HTTPS를 사용하면 애초에 메시지에 대한 탈취자체가 불가능하게 할 수 있는데 왜 HMAC을 추가로 사용해야 하는가? 사실 HTTPS는 통신 경로를 보호하는 장치이다. 만약 요청이 클라이언트에서 서버로 바로 전송되지 않고 로드밸런서, 프록시 서버, 메시지 큐와 같은 다양한 경로를 거치게 되면 HTTPS는 구간 별로 끊어질 수 있다. 하지만 HMAC은 메시지 자체를 보장하기 때문에 전송 경로 밖에서도 메시지를 보호한다.