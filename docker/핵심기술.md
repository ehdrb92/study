Docker는 애플리케이션을 컨테이너라는 표준화된 유닛에 담아 어디서든 동일하게 실행할 수 있게 해주는 기술입니다. 이를 가능하게 하는 Docker의 내부 구조는 크게 세 가지 핵심 기술의 조합으로 이루어져 있습니다.

Docker가 마치 독립된 운영체제처럼 동작하면서도 가벼운 이유는 리눅스 커널의 기능을 교묘하게 활용하기 때문입니다.

- 네임스페이스 (Namespaces - 격리): 컨테이너가 시스템의 특정 자원(프로세스 ID, 네트워크, 파일 시스템 등)만 볼 수 있도록 울타리를 칩니다. 덕분에 컨테이너 안의 프로세스는 마치 자신이 독립된 시스템에 있는 것처럼 착각하게 됩니다.
- 컨트롤 그룹 (Control Groups/cgroups - 제한): 컨테이너가 사용할 수 있는 자원의 양을 조절합니다. 특정 컨테이너가 CPU나 메모리를 독점하여 전체 시스템이 멈추는 것을 방지하는 역할을 합니다.
- 유니온 파일 시스템 (Union File System - 효율): 여러 개의 파일 시스템 레이어를 하나로 합쳐서 보여줍니다. Docker 이미지가 겹겹이 쌓인 '레이어' 구조를 가질 수 있는 이유이며, 변경된 부분만 저장하기 때문에 용량을 매우 효율적으로 사용합니다.

## 네임스페이스

네임스페이스(Namespaces)는 리눅스 커널이 제공하는 기능으로, 프로세스가 실행될 때 시스템 자원들을 격리된 공간으로 분리해 주는 역할을 합니다. 쉽게 비유하자면, 하나의 큰 아파트 건물(호스트 OS) 안에서 각 세대(컨테이너)가 서로의 집 안을 들여다볼 수 없도록 벽을 세우는 것과 같습니다.

리눅스 시스템에는 모든 프로세스가 공유하는 자원들이 있습니다. 네임스페이스는 이 자원들을 논리적으로 나누어, 컨테이너 안의 프로세스가 "이 시스템에는 나밖에 없구나" 혹은 "내가 이 시스템의 주인(root)이구나"라고 착각하게 만듭니다.

Docker는 다음과 같은 여러 종류의 네임스페이스를 조합하여 완벽한 격리 환경을 구축합니다.

- PID 네임스페이스 (Process ID): 컨테이너마다 독립적인 프로세스 번호를 부여합니다. 호스트에서는 PID가 1234번인 프로세스가 컨테이너 안에서는 **1번 프로세스(init)**로 보입니다.
- NET 네임스페이스 (Network): 가상 네트워크 장치, IP 주소, 라우팅 테이블 등을 격리합니다. 덕분에 컨테이너마다 독립적인 포트(예: 80번 포트)를 가질 수 있습니다.
- MNT 네임스페이스 (Mount): 파일 시스템의 마운트 지점을 격리합니다. 컨테이너는 호스트의 전체 파일 시스템이 아니라, 자신에게 할당된 특정 디렉토리만 루트(/) 폴더로 인식하게 됩니다.
- UTS 네임스페이스 (Unix Timesharing System): 호스트 이름(Hostname)과 도메인 이름을 독립적으로 설정할 수 있게 합니다.
- IPC 네임스페이스 (Inter-Process Communication): 프로세스 간 통신 통로를 격리하여, 다른 컨테이너의 프로세스와 섞이지 않도록 합니다.
- USER 네임스페이스: 컨테이너 안의 사용자 ID(UID)와 호스트의 UID를 다르게 매핑합니다. 컨테이너 내부에서는 root 권한을 갖더라도, 실제 호스트에서는 일반 사용자 권한으로 작동하게 하여 보안을 강화합니다.

만약 PID 네임스페이스가 없다면 우리가 기대하는 '독립된 환경'은 무너지고 말 거예요.

### 네임스페이스가 없을 때 생기는 주요 문제

- PID 1번(주인공) 쟁탈전: 리눅스 시스템에서 PID 1번은 시스템의 시작과 관리를 담당하는 매우 특별한 번호입니다. 많은 애플리케이션이 자신이 이 시스템의 주인공(PID 1)이라고 가정하고 동작하는데, 격리가 없다면 오직 하나의 컨테이너만 1번을 가질 수 있게 됩니다. 나머지 컨테이너들은 "왜 난 1번이 아니지?"라며 오류를 일으킬 수 있죠.
- 보안과 간섭: 옆집 컨테이너의 프로세스 번호를 훤히 다 볼 수 있다면 어떨까요? 실수로, 혹은 악의적으로 다른 컨테이너의 프로세스에 kill 명령을 보내 종료시킬 수도 있습니다. 우리 집 거실에서 옆집 TV를 맘대로 꺼버리는 것과 같은 상황이죠.
- 관리의 복잡성: 모든 컨테이너가 하나의 '번호표 기계'를 공유해야 하므로, 수천 개의 컨테이너가 떠 있는 환경에서는 PID 번호가 수십만 번대로 치솟아 관리가 매우 힘들어질 것입니다.

## 컨트롤 그룹

사용자께서 지적하신 대로, 운영체제(리눅스 커널) 입장에서는 '도커'라는 프로그램의 내부 사정에는 관심이 없습니다. 하지만 커널은 시스템의 자원을 효율적으로 관리해야 하는 관리자이고, 도커는 그 관리자에게 **"이 프로세스 묶음은 자원을 이만큼만 쓰게 해줘"**라고 요청하는 요청자 역할을 합니다.

cgroups는 리눅스 커널이 프로세스들을 그룹으로 묶고, 그 그룹이 사용할 수 있는 자원(CPU, 메모리, 네트워크 대역폭 등)을 제한하거나 우선순위를 부여하는 기능입니다.

- 자원 제한 (Resource Limiting): 특정 그룹이 사용할 수 있는 메모리 용량이나 CPU 사용 시간을 제한합니다.
- 우선순위 (Prioritization): 특정 그룹에 더 많은 CPU 사이클이나 디스크 I/O 처리량을 할당합니다.
- 계측 (Accounting): 그룹이 자원을 얼마나 사용하고 있는지 모니터링합니다.
- 제어 (Control): 그룹 내의 모든 프로세스를 한꺼번에 멈추거나(freeze) 다시 시작하게 할 수 있습니다.

도커와 운영체제의 협업 방식

도커는 사용자가 `docker run --memory="512m"` 같은 명령을 내리면 내부적으로 다음과 같이 움직입니다.

- 명령 전달: 도커 엔진이 리눅스 커널에게 "새로운 cgroup을 만들고, 이 그룹의 메모리 한도를 512MB로 설정해줘"라고 요청합니다.
- 프로세스 배치: 도커가 컨테이너 내부에서 실행할 프로세스를 생성한 뒤, 그 프로세스의 ID(PID)를 해당 cgroup에 등록합니다.
- 커널의 감시: 이제부터 운영체제(커널)는 그 프로세스가 메모리를 얼마나 쓰는지 감시합니다. 만약 512MB를 넘으려고 하면 커널이 직접 개입하여 차단하거나 프로세스를 종료시킵니다.

만약 우리가 메모리 제한을 512MB로 설정한 컨테이너 안에서, 프로그램이 실수로 1GB의 메모리를 할당받으려고 하면 어떤 일이 벌어질까요?

사용자의 입장에서 생각하면 **"유연하게 공간을 빌려주는 것"**이 훨씬 친절하고 합리적으로 느껴지죠! 실제로 일반적인 운영체제(Windows, macOS 등)는 메모리가 부족하면 하드 디스크의 일부를 메모리처럼 사용하는 '스왑(Swap)' 기술 등을 동원해 어떻게든 프로그램을 살려두려고 노력합니다.

하지만 **도커(Docker)**와 같은 컨테이너 환경에서는 이야기가 조금 달라집니다.

도커가 cgroups를 통해 메모리를 제한하는 이유는 **"예측 가능성"**과 "전체 시스템의 안전" 때문입니다.

- 공유 경제의 비극 방지: 컨테이너 A가 "잠시만 빌릴게요" 하고 호스트의 여유 메모리를 다 써버리면, 정당하게 자기 몫을 쓰려던 컨테이너 B가 굶게 됩니다. 격리(Isolation)의 핵심은 서로의 영역을 침범하지 않는 것이기에, 도커는 정해진 선을 넘으면 엄격하게 대처합니다.
- OOM Killer (Out Of Memory Killer): 설정된 메모리 한도를 넘어서면, 리눅스 커널은 OOM Killer라는 장치를 깨웁니다. 이 장치는 시스템 전체가 멈추는 것을 막기 위해, 한도를 넘긴 범인(프로세스)을 즉시 종료(Kill) 시켜버립니다.

[!IMPORTANT] 도커 컨테이너를 운영하다가 갑자기 컨테이너가 죽고 상태 코드가 137이라면, 대부분 이 OOM Killer에게 "진압"당한 경우입니다.

## 유니온 파일 시스템 (UnionFS)

이제 컨테이너가 어떻게 남들과 섞이지 않고(네임스페이스), 어떻게 자원을 제한받는지(cgroups) 알게 되었습니다. 이제 마지막으로 **"어떻게 그렇게 가볍고 빠르게 실행되는가?"**에 대한 답인 유니온 파일 시스템을 알아볼 차례입니다.

도커 이미지를 보면 Layer 1, Layer 2 처럼 층이 쌓여 있는 것을 보신 적이 있을 거예요. 만약 10개의 컨테이너가 모두 같은 '우분투(Ubuntu)' 이미지를 기반으로 실행된다면, 도커는 이 우분투 파일을 10번 복사해서 가질까요?

도커는 모든 데이터를 하나의 덩어리로 저장하지 않고, **레이어(Layer)**라고 불리는 여러 개의 층으로 나누어 관리합니다.

도커 이미지를 만들 때 실행하는 한 줄 한 줄의 명령은 새로운 레이어가 됩니다. 유니온 파일 시스템은 이 여러 개의 레이어를 위에서 아래로 내려다보았을 때 하나의 합쳐진 파일 시스템처럼 보이게 해줍니다.

- 이미지 레이어 (ReadOnly): 한 번 생성되면 절대로 변하지 않는 읽기 전용 층입니다. 여러 컨테이너가 같은 이미지를 사용한다면, 이 레이어들을 공유해서 사용합니다. 덕분에 용량을 획기적으로 줄일 수 있죠.
- 컨테이너 레이어 (Writable): 컨테이너가 실행될 때 이미지 레이어 제일 위에 아주 얇게 쌓이는 '쓰기 가능' 층입니다. 컨테이너 안에서 파일을 새로 만들거나 수정하면 오직 이 층에만 기록됩니다.

만약 읽기 전용인 이미지 레이어에 있는 파일을 수정해야 한다면 어떻게 할까요? 도커는 그 파일을 컨테이너 레이어로 **복사(Copy)**해온 뒤 수정합니다. 원본(이미지)은 건드리지 않고, 바뀐 부분만 따로 관리하는 방식이죠.

도커는 Dockerfile의 각 명령어를 하나의 레이어로 저장합니다. 이전 레이어가 변경되면 그 위에 쌓인 모든 레이어는 더 이상 유효하지 않게 되는데, 이를 **캐시 무효화(Cache Invalidation)**라고 불러요.

- 상호 의존성: 상위 레이어는 하위 레이어의 상태를 기반으로 생성됩니다.
- 변경 감지: 명령어 자체가 수정되거나, COPY로 가져오는 파일의 내용이 바뀌면 도커는 "기반이 바뀌었으니 이후 단계는 믿을 수 없다"고 판단합니다.