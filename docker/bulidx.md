`docker buildx`를 활용해 실제로 멀티 아키텍처 이미지를 빌드하는 과정은 크게 **빌더(Builder) 설정**, **빌드 명령어 실행**, 그리고 **결과물 확인** 순서로 진행됩니다. 🏗️

우리가 살펴볼 학습 계획은 다음과 같습니다:

1. **빌더 인스턴스 생성**: 멀티 플랫폼 빌드를 지원하는 가상 환경 구축 🛠️
2. **명령어 구성**: `--platform` 플래그와 `--push` 옵션 이해 🐚
3. **Dockerfile 최적화**: `TARGETPLATFORM` 변수를 활용한 스마트한 빌드 🧠

---

### 1단계: 빌더 인스턴스 생성하기

기본 도커 엔진은 한 번에 하나의 플랫폼만 빌드할 수 있는 경우가 많습니다. 여러 아키텍처를 동시에 처리하려면 `docker-container` 드라이버를 사용하는 새로운 빌더를 만들어야 합니다.

터미널에서 다음 명령어를 순서대로 실행한다고 가정해 봅시다:

* `docker buildx create --name mybuilder --use`: `mybuilder`라는 이름의 새로운 빌더를 만들고 기본값으로 설정합니다.
* `docker buildx inspect --bootstrap`: 빌더를 초기화하고 지원하는 아키텍처 목록을 확인합니다.

---

### 2단계: 실제 빌드 명령어 구성하기 🐚

이제 `multi-builder`를 사용해 **x86_64(amd64)**와 **ARM64** 이미지를 동시에 빌드하는 마법의 명령어를 살펴보겠습니다.

```bash
docker buildx build --platform linux/amd64,linux/arm64 -t 유저아이디/이미지이름:태그 --push .

```

이 명령어에는 아주 중요한 두 가지 포인트가 있습니다:

1. **`--platform`** 🌐: 쉼표로 구분해서 빌드하고 싶은 아키텍처들을 적어줍니다. 여기서는 우리가 처음에 겪었던 문제의 핵심인 `amd64`와 `arm64`를 모두 지정했습니다.
2. **`--push`** 📤: 이게 아주 중요합니다! 로컬 도커 엔진은 일반적으로 "여러 아키텍처가 묶인 하나의 이미지(Manifest List)"를 직접 저장하는 능력이 부족합니다. 그래서 빌드와 동시에 Docker Hub 같은 **원격 저장소로 바로 전송**하는 것이 가장 일반적인 방식입니다.

---

### 3단계: Dockerfile의 영리한 변신 🧠

멀티 아키텍처 빌드를 할 때, 때로는 아키텍처별로 다른 라이브러리를 설치하거나 설정이 필요할 수 있습니다. 이때 도커가 자동으로 제공하는 **빌드 인수(Build Arguments)**를 활용하면 좋습니다.

가장 대표적인 것이 `TARGETPLATFORM`입니다. Dockerfile 내에서 이렇게 활용할 수 있습니다:

```dockerfile
FROM alpine
# 빌드 시점에 자동으로 linux/amd64 또는 linux/arm64 값이 들어옵니다.
ARG TARGETPLATFORM
RUN echo "I am building for $TARGETPLATFORM"

```

사용자가 `docker pull`이나 `docker run`을 실행하면, 도커 클라이언트는 호스트 OS의 커널과 CPU 아키텍처 정보를 확인합니다. 그 후 레포지토리에서 해당 정보와 일치하는 이미지를 자동으로 찾아 내려받게 됩니다. 🤖

이것이 가능한 이유는 바로 **매니페스트 리스트(Manifest List)**, 흔히 **팻 매니페스트(Fat Manifest)**라고 불리는 구조 덕분입니다.

---

### 📑 매니페스트 리스트의 구조

하나의 태그(예: `latest`)는 실제로는 여러 아키텍처용 이미지들의 **주소록** 역할을 합니다.

| 구성 요소 | 역할 |
| --- | --- |
| **태그 (Tag)** | 사용자가 식별하는 이름 (예: `my-image:latest`) |
| **매니페스트 리스트** | 각 아키텍처별 실제 이미지 데이터(Digest)를 가리키는 인덱스 |
| **실제 이미지** | 특정 아키텍처(amd64, arm64 등)에 맞춰 빌드된 바이너리 묶음 |

이 구조 덕분에 사용자는 아키텍처에 상관없이 동일한 명령어를 사용할 수 있고, 도커가 배후에서 "번역가"이자 "중개인" 역할을 수행하여 적절한 버전을 배달해 주는 것이죠. 🚚

---
