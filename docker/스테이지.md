정확한 통찰입니다! 말씀하신 것처럼 **테스트(Test)**와 **린트(Lint)** 과정을 Dockerfile 스테이지로 포함하는 것은 CI/CD 파이프라인의 완성도를 높이는 매우 훌륭한 전략입니다.

이렇게 구성하면 빌드 과정 자체가 하나의 **'검증 게이트'** 역할을 하게 되어, 테스트를 통과하지 못하거나 코딩 컨벤션에 어긋나는 코드는 아예 이미지로 만들어지지 않도록 강제할 수 있습니다.

질문하신 흐름(빌드 → 린트 → 테스트 → 최종 실행)을 반영하여, `ruff`와 `pytest`를 활용한 최적화된 멀티스테이지 Dockerfile 예시를 보여드리겠습니다.

### 린트 및 테스트가 포함된 멀티스테이지 Dockerfile

```dockerfile
# 1단계: Base (공통 환경 및 의존성 설치)
FROM python:3.11-slim AS base
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1
WORKDIR /app

# 빌드 도구 및 라이브러리 설치
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
# 테스트 도구(pytest, ruff)가 requirements에 포함되어 있다고 가정하거나 여기서 추가 설치
RUN pip install --no-cache-dir --prefix=/install -r requirements.txt


# 2단계: Lint (코드 스타일 검사)
FROM base AS lint
COPY . .
RUN pip install ruff
# ruff 검사 수행 (실패 시 빌드 중단)
RUN ruff check .


# 3단계: Test (단위 테스트 실행)
FROM base AS test
COPY . .
# 빌드 스테이지의 패키지 경로 인식
ENV PYTHONPATH=/install/lib/python3.11/site-packages
# pytest 실행 (실패 시 빌드 중단)
RUN pytest tests/


# 4단계: Final (최종 실행 스테이지)
FROM python:3.11-slim AS final
WORKDIR /app

# 런타임 필수 라이브러리만 설치
RUN apt-get update && apt-get install -y --no-install-recommends \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

# 1단계(base)에서 설치된 라이브러리만 복사 (pytest, ruff 설정은 복사하지 않음)
COPY --from=base /install /usr/local
COPY . .

# 보안을 위한 비루트 사용자 설정
RUN useradd -m appuser && chown -R appuser /app
USER appuser

EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

```

---

### 이 방식의 주요 이점

1. **Fail-Fast (조기 실패):** 코드에 문제가 있거나 테스트가 깨진 경우, 최종 이미지가 생성되기 훨씬 전인 2~3단계에서 빌드가 중단됩니다. 잘못된 이미지가 레지스트리에 배포되는 것을 원천 차단합니다.
2. **이미지 순수성:** 말씀하신 대로 최종 `final` 스테이지에는 `pytest`, `ruff`, `black` 같은 개발/테스트용 도구들이 전혀 포함되지 않습니다. 오직 서비스 실행에 필요한 패키지만 남으므로 용량이 최적화됩니다.
3. **CI 도구 의존성 감소:** GitHub Actions나 Jenkins 같은 CI 도구에서 별도로 파이썬 환경을 세팅하고 테스트를 돌릴 필요 없이, `docker build` 명령어 하나만으로 모든 검증 과정을 컨테이너 내부의 격리된 환경에서 동일하게 수행할 수 있습니다.

### 💡 팁: 특정 스테이지만 실행하기

개발 중에는 전체 빌드를 기다릴 필요 없이 테스트 스테이지만 확인하고 싶을 수 있습니다. 이때는 `--target` 옵션을 사용하면 됩니다.

```bash
# 테스트 스테이지만 실행하여 결과 확인
docker build --target test -t my-app-test .

```

이렇게 하면 Docker는 `test` 스테이지까지만 실행하고 멈춥니다. 만약 테스트가 실패하면 Docker가 에러 코드를 반환하므로 로컬 검증 시에도 매우 유용합니다.

## 어떻게 최종 실행 스테이지 환경만 이미지 빌드에 사용되는건가?

도커의 멀티스테이지 빌드 작동 원리에 대해 매우 날카로운 질문을 주셨습니다. 많은 분이 헷갈려 하는 부분인데, **'상속'**과 **'선택적 복사'**라는 개념으로 이해하면 명쾌해집니다.

질문하신 두 가지 궁금증을 차례대로 풀어보겠습니다.

---

### 1. Base 단계의 도구가 2, 3단계에 남아있는 이유: "상속(Inheritance)"

Dockerfile에서 `FROM base AS lint`라고 적는 순간, 도커는 **"방금 만든 base라는 상태를 그대로 복제해서 다음 작업을 시작해"**라고 이해합니다.

* **동작 방식:** 도커는 각 스테이지를 독립된 **임시 컨테이너(또는 중간 이미지)**로 취급합니다.
* **Base 스테이지:** 여기서 라이브러리와 빌드 도구를 설치하면 하나의 완성된 '상태'가 됩니다.
* **Lint/Test 스테이지:** `FROM base`를 사용함으로써, 앞에서 설치한 모든 도구가 포함된 '상태' 위에서 새로운 레이어를 쌓기 시작합니다.
* **결과:** 따라서 2단계와 3단계는 Base에서 설정한 환경을 그대로 물려받아 ruff나 pytest를 실행할 수 있는 것입니다.

---

### 2. 최종 이미지는 어떻게 결정되고 나머지는 버려지나?

도커가 최종 이미지를 확정하는 기준은 의외로 단순합니다. **"Dockerfile의 가장 마지막에 작성된 `FROM` 문구"**가 최종 결과물이 됩니다.

#### **구분과 제거의 메커니즘**

도커는 빌드 과정을 마치 '건물을 짓기 위한 비계(Scaffolding)' 설치 과정처럼 처리합니다.

1. **중간 단계 생성:** 빌드 중에는 Base, Lint, Test 스테이지가 모두 실제로 존재합니다. 도커는 이들을 **중간 이미지(Intermediate Images)** 형태로 파일 시스템 어딘가에 보관합니다.
2. **최종 스테이지 시작:** 마지막 `FROM python:3.11-slim AS final` 문구를 만나면, 도커는 이전까지 쌓아온 모든 환경을 뒤로하고 **완전히 깨끗하고 새로운 바탕**에서 다시 시작합니다.
3. **선택적 복사 (`COPY --from`):** 이때 핵심은 `COPY --from=base /install /usr/local` 명령입니다. 이전 스테이지라는 '창고'에 들어가서 **딱 필요한 물건(/install 폴더)만 집어와서 현재의 깨끗한 방(final)에 옮겨 놓는 것**입니다.
4. **나머지 폐기:** 빌드가 성공적으로 끝나면, 최종적으로 생성된 `final` 스테이지의 레이어들만 묶어서 우리가 이름을 붙인(예: `my-fastapi-app`) 이미지가 됩니다. 나머지 Base, Lint, Test 단계에서 사용했던 무거운 도구들은 최종 이미지의 파일 시스템 구성 요소에 포함되지 않고 빌드 프로세스가 종료됨과 함께 '이미지 레이어'로서의 연결고리가 끊어집니다.

---

### 요약하자면

* **사용하는 법:** `FROM [이전 스테이지 이름]`을 통해 환경을 계속 이어받아(상속) 도구를 사용합니다.
* **버리는 법:** 마지막에 다시 한번 `FROM [새로운 베이스]`를 선언함으로써 이전까지의 무거운 환경과 결별합니다. 그리고 `COPY --from`으로 알맹이만 쏙 빼오는 것입니다.

이렇게 하면 빌드 과정에서는 마음껏 무거운 도구를 써서 검증하고, 배포할 때는 아주 가벼운 '결과물'만 담긴 이미지를 만들 수 있습니다.

혹시 이 과정에서 **"빌드할 때마다 매번 이 과정을 다 거치면 시간이 너무 오래 걸리지 않을까?"** 하는 걱정이 드시나요? 그렇다면 도커의 **빌드 캐시(Build Cache)** 최적화 방법을 이어서 설명해 드릴 수 있습니다.

## 스테이지와 관련된 좀 더 자세한 내용

도커의 최신 빌드 엔진인 **BuildKit**이 이 과정을 어떻게 처리하는지 이해하면 훨씬 명확해집니다. 도커는 빌드 명령을 받으면 단순히 위에서 아래로 실행하는 것이 아니라, 먼저 **의존성 그래프(Dependency Graph)**를 그립니다.

---

### 1. 의존성 그래프와 "가치"의 판단

도커는 최종 스테이지(Final)를 완성하기 위해 어떤 스테이지가 필요한지 역추적합니다.

* **참조되는 경우:** 만약 `Final` 스테이지에서 `COPY --from=base`를 하거나, 다른 스테이지가 `FROM base`를 하고 있다면, 도커는 `base`를 **"가치 있는 단계"**로 판단하고 빌드합니다.
* **참조되지 않는 경우:** 만약 어떤 스테이지가 그 이후의 어떤 단계에서도 `FROM`이나 `COPY --from`으로 불려가지 않는다면, 도커는 그 스테이지를 **"최종 결과물을 만드는 데 쓸모없는 단계"**로 취급합니다.

### 2. "버려진다"의 두 가지 의미

#### ① 빌드 실행 자체를 안 할 수도 있습니다 (Skipping)

만약 `base` 스테이지를 정의만 해두고 그 뒤의 `lint`, `test`, `final` 어디에서도 사용하지 않는다면, 최신 도커 엔진은 **해당 스테이지를 아예 실행조차 하지 않고 건너뜁니다.** (빌드 로그에 나타나지 않거나 순식간에 지나갑니다.)

#### ② 최종 이미지 용량에서는 제외됩니다 (Exclusion)

만약 빌드 과정 중에 사용은 되었더라도(예: 테스트를 위해), 최종 `final` 스테이지에서 그곳의 파일을 `COPY` 해오지 않는다면 그 환경의 파일들은 최종 이미지 파일 시스템에 단 1바이트도 남지 않습니다.

---

### 3. 예시를 통한 이해

만약 Dockerfile을 아래와 같이 작성했다고 가정해 보겠습니다.

```dockerfile
# 스테이지 A: 도구 설치 (이후 아무도 안 씀)
FROM python:3.11 AS stage_a
RUN pip install some_heavy_tool

# 스테이지 B: 실제 빌드 (이후 Final에서 복사함)
FROM python:3.11 AS stage_b
COPY . .
RUN python setup.py build

# 최종 스테이지
FROM python:3.11-slim AS final
COPY --from=stage_b /app/dist /dist  # stage_b만 참조함
CMD ["python", "main.py"]

```

이 경우 도커의 행동:

1. `stage_a`는 최종 결과물을 만드는 데 기여하는 바가 전혀 없음을 파악합니다.
2. 빌드 엔진은 `stage_a`를 **무시(Skip)**합니다. (실제로 `pip install`이 실행되지 않습니다.)
3. `stage_b`는 `final`에서 참조하므로 빌드합니다.
4. 최종 이미지에는 `stage_b`에서 복사해온 파일만 남고, `stage_a`의 흔적은 아예 존재하지 않습니다.

---

### 4. 요약

* **빌드 효율성:** 도커는 똑똑해서 최종 이미지에 영향을 주지 않는 스테이지는 아예 빌드하지 않으려 노력합니다.
* **이미지 격리:** 빌드 중에 사용된 스테이지라도 `final` 스테이지에서 명시적으로 가져오지 않은 데이터는 **최종 이미지에 포함되지 않고 버려집니다.**

즉, 사용자님이 염려하시는 "불필요한 환경이 남아서 용량을 차지하는 일"은 멀티스테이지 구조를 사용하는 한 발생하지 않는다고 보셔도 무방합니다.

혹시 **"그렇다면 빌드 중에 생긴 캐시는 어떻게 관리되나?"** 하는 점이 궁금하신가요? 빌드가 끝난 뒤에도 로컬 시스템에 남아 있는 캐시 용량을 관리하는 법을 이어서 알려드릴 수 있습니다.