REST API를 만들기위한 6가지 법칙에 대해서 알아보자.


## Client-Server Decoupling (클라이언트-서버 독립성)

클라이언트와 서버가 독립적으로 개발되고 진화할 수 있도록 관심사를 분리한다. 클라이언트는 사용자 인터페이스에, 서버는 데이터에 집중한 개발을 한다. 프론트엔드와 백엔드 간의 독립적인 개발과 배포가 핵심이다.

전자상거래 플랫폼을 개발한다고 하면 클라이언트와 서버는 다음과 같이 독립적인 개발을 수행해야한다.

- 클라이언트측(프론트엔드)
  - 웹 브라우저 (React/Vue 앱)
  - 모바일 앱 (IOS/Android)
  - 관리자 대시보드
  - 파트너사 시스템

- 서버측(백엔드)
  - 상품 데이터베이스 관리
  - 주문 처리 로직
  - 결제 시스템 연동
  - 재고 관리
  - API 엔드포인트 제공

해당 원칙을 지키게 되면 어떤 이점이 있을까?

예시 첫 번째 UI 개편을 할 때, 클라이언트 팀이 웹사이트 디자인을 완전히 바꾸는 작업을 해고 서버에 요구되는 데이터가 동일하게 유지되면 백엔드는 별도의 작업이 전혀 필요없다.

예시 두 번째 서버 성능 개선을 할 때, 데이터베이스를 MySQL에서 PostgreSQL로 변경하거나, 캐싱 시스템을 도입하거나, 서버 로직을 최적화 하더라도 API 응답만 동일하면 클라이언트에는 아무런 영향이 없다.

- 백엔드, 프론트엔드, 모바일 팀이 각자 독립적 배포 주기를 가질 수 있다.
- 서버, 클라이언트가 기술 스택 선택에 자유롭다.


## Stateless (무상태)

서버는 클라이언트의 이전 요청을 기억하지 않는다. 즉, 각 HTTP 요청은 그 자체로 완전한 정보를 담고 있어야 한다는게 핵심이다. 서버가 클라이언트 요청 상태를 저장하게 되면, 서버 재시작 시 모든 사용자가 다시 로그인 하거나, 서버가 수평 확장을 할 경우 다수의 서버에 동기화가 필요하다.

그렇기 때문에 상태를 저장하지 않고 JWT, API Key와 같은 방식을 통해 인증하면, 서버 간의 동기화가 필요 없어져서 확장에 용이하고 서버 재시작이나 장애 시 클라이언트 상태 유지가 좋아진다. 그리고 서버 로직이 단순해져 디버깅과 테스트가 용이해진다.

대신 모든 요청에 인증 관련 데이터가 포함되어야 하기 때문에, 데이터 크기에 의한 네트워크 오버헤드, 토큰 검증에 대한 비용, 보안 문제 등이 야기될 수 있다.

그런데 이러한 의문이 생길 수 있다. 서버의 메모리에 사용자 세션 데이터를 저장하면 확장성, 안정성 등이 문제가 되지 않는다. 그렇다면 이건 무상태성인가?

답은 아니다. 관계형 데이터베이스 서버 혹은 Redis와 같은 원격 메모리 서버에 세션 데이터를 저장하더라도 Stateful에 해당한다. REST에서 말하는 Stateless의 상태는 저장 위치가 중요한 것이 아니라 서버가 클라이언트의 상태를 기억하는 방식 자체를 의미한다. 데이터베이스나 원격 메모리 또한 크게 보면 서버에 속하기 때문에 상태를 저장한다고 볼 수 있다. 또한 클라이언트 측에서 세션 ID만 보내면 이를 데이터베이스를 통해 추적을 하는 과정이 추가되거나, 세션의 생명주기 관리를 서버가 직접해야하고, 서버 측 세션 데이터에 의존하게 되기 때문에 더욱이 Stateful 하다고 볼 수 있다.

실무에서 Stateless의 경우 지키기 어려운 경우들이 존재한다.

- 사용자가 로그아웃을 해서 보안상 토큰을 즉시 무효화해야 할 때
- 사용자별 API 호출에 제한을 걸어야할 때
- 채팅, 알람과 같은 서비스 제공시

이런 경우들에는 어쩔 수 없이 상태를 일부 저장하는 하이브리드 접근 방식을 사용할 수 밖에 없다.


## Cacheable (캐시 가능)

응답이 캐시 가능한지 여부를 명시하고, 적절한 캐싱 전략으로 성능을 최적화하는 것이 핵심이다. 클라이언트 혹은 중간 프록시가 응답을 저장해두고 재사용할 수 있도록 한다.

일반적으로 자주 변하지 않는 데이터를 응답할 때, HTTP 헤더에 Cache-Control(max-age), ETag 등의 메타데이터를 함께 제공하여 같은 데이터에 대한 요청을 하지 않도록 하거나, 서버에서 데이터의 버전을 비교하여 변경이 발생하지 않았을 때, 데이터를 쿼리하지 않고 데이터가 변하지 않았다는 메시지만 전달하여 자원을 아낀다. 하지만 데이터가 개인화된 데이터이거나, 실시간으로 변하는 데이터에는 적용할 수 없다.

계층별로는 브라우저, CDN, API Gateway/프록시에 캐시를 저장할 수 있다.

하지만 캐시에도 한계점은 존재한다.

- 캐시 무효화를 적절하게 진행하지 않을 경우 데이터 일관성에 문제가 생길 수 있다.
- 데이터의 수정 혹은 삭제 작업에 따라 수 많은 캐시를 무효화해야 하는 어려움이 있을 수 있다.
- 메모리 사용량 증가에 따른 비용이 발생할 수 있다.
- 디버깅이 복잡해질 수 있다. (개발자가 API를 수정했는데, 캐시 문제인지 코드 문제인지 파악 어려움)

실무에서는 계층별 TTL(Time To Live) 전략, 캐시 키 설계, 조건부 요청 활용, 캐시 워밍을 활용할 수 있다.


## Uniform Interface (통일된 인터페이스)

네 번째는 통일된 인터페이스이다. 이는 REST에서 가장 중요하면서도 복잡한 원칙으로, 4개의 하위 제약조건으로 구성된다.

1. Resource Identification(리소스 식별)

```js
// 리소스를 명확하게 식별
GET /api/users/123           // 특정 사용자
GET /api/users/123/orders    // 특정 사용자의 주문들
GET /api/products/456        // 특정 상품
GET /api/categories/1/products  // 특정 카테고리의 상품들
```

2. Resource Manipulation through Representations(표현을 통한 리소스 조작)

HTTP 메서드의 통일된 사용
```js
// 사용자 리소스에 대한 표준 CRUD
GET /api/users/123          // 조회
POST /api/users             // 생성
PUT /api/users/123          // 전체 수정
PATCH /api/users/123        // 부분 수정
DELETE /api/users/123       // 삭제

// 주문 리소스도 동일한 패턴
GET /api/orders/456
POST /api/orders
PUT /api/orders/456
DELETE /api/orders/456
```

요청/응답 형식의 일관성
```js
// 모든 API가 동일한 응답 구조
// 성공 응답
{
    "success": true,
    "data": { ... },
    "metadata": {
        "timestamp": "2024-01-15T10:00:00Z",
        "version": "1.0"
    }
}

// 에러 응답
{
    "success": false,
    "error": {
        "code": "USER_NOT_FOUND",
        "message": "사용자를 찾을 수 없습니다",
        "details": { ... }
    }
}
```

3. Self-Descriptive Messages(자기 서술적 메시지)

Content-Type과 메타데이터 명시
```js
// 요청
POST /api/users
Content-Type: application/json
Accept: application/json
Authorization: Bearer token123

{
    "name": "홍길동",
    "email": "hong@example.com"
}

// 응답
HTTP/1.1 201 Created
Content-Type: application/json
Location: /api/users/789
ETag: "user-789-v1"

{
    "id": 789,
    "name": "홍길동",
    "email": "hong@example.com",
    "createdAt": "2024-01-15T10:00:00Z"
}
```

API 문서화와 스키마
```js
// OpenAPI/Swagger 스펙 예시
{
    "paths": {
        "/users/{id}": {
            "get": {
                "summary": "사용자 조회",
                "parameters": [{
                    "name": "id",
                    "in": "path",
                    "required": true,
                    "schema": { "type": "integer" }
                }],
                "responses": {
                    "200": {
                        "description": "사용자 정보",
                        "content": {
                            "application/json": {
                                "schema": { "$ref": "#/components/schemas/User" }
                            }
                        }
                    }
                }
            }
        }
    }
}
```

4. HATEOAS (Hypermedia as the Engine of Application State)

```js
// 일반적인 응답 (HATEOAS 없음)
GET /api/users/123
{
    "id": 123,
    "name": "홍길동",
    "email": "hong@example.com"
}

// HATEOAS 적용된 응답
GET /api/users/123
{
    "id": 123,
    "name": "홍길동",
    "email": "hong@example.com",
    "_links": {
        "self": { "href": "/api/users/123" },
        "orders": { "href": "/api/users/123/orders" },
        "edit": { "href": "/api/users/123", "method": "PUT" },
        "delete": { "href": "/api/users/123", "method": "DELETE" }
    }
}
```

사실 실무에서 위 조건들을 모두 충족하여 REST API를 개발한다는 것은 굉장히 힘들다. 그래서 어느정도 절충을 하면서 개발하는 경우가 대다수이다.


## Layered System(계층화된 시스템)

각 구성요소는 바로 인접한 꼐층과만 상호작용하며, 다른 계층의 내부 구조를 알지 못하는게 핵심이다. 클라이언트는 서버와 통신할 때, 중간에 프록시나 게이트웨이가 있는지 알지 못해야한다.

```
일반적인 계층 구조

┌─────────────────┐
│   클라이언트    │ (브라우저, 모바일 앱)
└─────────────────┘
         │ HTTP 요청
         ▼
┌─────────────────┐
│   CDN/캐시      │ (CloudFlare, AWS CloudFront)
└─────────────────┘
         │
         ▼
┌─────────────────┐
│  로드밸런서     │ (NGINX, HAProxy, AWS ALB)
└─────────────────┘
         │
         ▼
┌─────────────────┐
│  API Gateway    │ (Kong, AWS API Gateway)
└─────────────────┘
         │
         ▼
┌─────────────────┐
│  웹 서버        │ (NGINX, Apache)
└─────────────────┘
         │
         ▼
┌─────────────────┐
│ 애플리케이션    │ (Node.js, Java Spring)
└─────────────────┘
         │
         ▼
┌─────────────────┐
│   데이터베이스  │ (MySQL, PostgreSQL)
└─────────────────┘
```

계층화된 시스템 구조를 사용하면 어떤 이점이 있는가?

첫 번째로 확장성이다. CDN의 경우 필요에 따라 전 세계 지점별로 추가를 하고, 로드밸런서의 존재로 수평 확장된 애플리케이션 서버에 적절한 트래픽 분배가 가능하다.

두 번째는 보안 강화이다. 각 계층별로 역할에 따라 보안을 위한 작업을 한다. CDN은 DDOS 방어, Bot 차단, API Gateway는 API 키 검증, OAuth 토큰 검증, 웹 서버는 HTTPS 종료, 헤더 보안 등이 있다.

세 번째는 장애 격리 및 복구이다. 특정 계층 장애 시 다른 계층이 대응 가능하다.

네 번째는 성능 최적화. CDN은 지리적으로 가까운 위치에서 응답, 캐시는 자주 요청되는 데이터를 메모리에서 빠르게 응답, 로드밸런서는 서버 부하에 따라 자동 분배.

다섯 번째는 기술적 진화와 교체이다. 특정 계층에서 필요에 따라 기술 스택을 교체해도 다른 계층에는 영향이 없다.

하지만 한계점도 존재한다.

첫 번째는 너무 많은 계층 간의 이동에 의해 지연 시간이 증가할 수 있다.

두 번째는 복잡성 증가로 인한 디버깅에 어려움이 생길 수 있다.

세 번째는 각 계층 간 네트워크 통신에 따른 오버헤드가 있을 수 있다.

네 번째는 단일 장애 지점 위협이 있을 수 있다. API Gateway가 하나만 존재한다면, 여기에 장애가 생겼을 때 모든 시스템이 마비된다.

다섯 번째는 유사하게 복잡성에 의한 관리의 어려움이다.


## Code on Demand (요청 시 코드 전송) - 선택사항

이는 서버가 클라이언트로 실행 가능한 코드를 전송하여 클라이언트의 기능을 동적으로 확장한다는 개념이다. 이는 REST 원칙 중 유일하게 선택사항이며, 일반적으로 사용되는 경우가 없다.

동작할 코드를 전송하기 때문에 다음의 이점이 있을 수 있다.

- 동적 기능 확장
- 실시간 비즈니스 로직 업데이트
- 개인화 및 A/B 테스트
- 오프라인 기능 확장

하지만 한계점이 치명적이다.

- 보안 위험성
- 성능 오버헤드
- 클라이언트 호환성 문제
- 디버깅의 어려움
- 캐싱과 버전 관리 복잡성

일반적으로 실무에서 사용되는 것을 보기 어려운 원칙이다.