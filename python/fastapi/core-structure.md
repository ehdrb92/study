fastapi는 기본적으로 클라이언트의 요청을 다음과 같은 3가지 큰 구성에 의해 처리된다.

`서버 <-> 미들웨어 <-> 애플리케이션`

클라이언트에서 요청을 보내고 응답을 보낼 때의 흐름을 순서로 표현하면 다음과 같다.

서버(Uvicorn)는 HTTP 요청을 받고 해당 문자를 ASGI 규격에 맞게 전처리를 한뒤 fastapi로 전달한다. 해당 호출은 먼저 fastapi의 미들웨어를 거친다. 미들웨어에서 요청 데이터에 대한 작업 처리를 진행한 뒤, 애플리케이션으로 전달된다. 여기서 애플리케이션은 HTTP의 path에 매칭되는 router 함수를 의미한다. router 함수의 코드를 모두 수행한 뒤 반환된 데이터가 미들웨어로 돌아온다. 추가로 미들웨어의 작업을 끝낸 뒤 서버로 전달된 후 서버는 해당 응답 데이터를 적절한 HTTP 응답 형태로 구성하여 클라이언트에 응답한다.

## 미들웨어

fastapi는 기본적으로 두 가지의 미들웨어를 가지고 있다.

- 서버 에러 미들웨어: 전체 애플리케이션의 가장 바깥쪽에서 래퍼 역할을 하며, 하위(내부) 계층에서 처리되지 않고 raise된 모든 에러를 잡아서 서버 프로그램이 종료되지 않도록한다. 에러가 여기서 잡히면, 클라이언트에게 HTTP 500 응답을 전달한다.
- 예외 미들웨어: 애플리케이션 수준에서 `@app.exception_handler`와 같이 별도롤 개발자가 설정한 예외에 대해 적절한 HTTP 응답으로 변환한다. `HTTPException`과 같은 특정 예외를 처리하며, 사용자가 정의한 커스텀 예외에 대한 핸들링을 한다. 여기서 처리되지 못한 예외가 최종적으로 서버 에러 미들웨어로 전달된다.

만약 개발자가 별도로 추가한 미들웨어의 경우 위 두 미들웨어의 내부에 위치하게 된다.

## 핸들링 함수(router)의 실행방식

fastapi는 기본적으로 비동기 기반의 ASGI 표준을 활용한 웹 애플리케이션이다. 그렇기 때문에 요청이 들어오면 이들을 처리하는 하나의 이벤트 루프에 의해 작업이 처리된다. 하지만 무조건 비동기 핸들링 함수만 정의해야하는 것은 아니다. 동기 핸들링 함수는 별도의 처리 방식이 존재한다.

먼저 `async def`로 정의된 비동기 핸들러 함수는 기본적인 방식과 동일하게 비동기 방식에 의해 이벤트 루프로 처리된다. fastapi + uvicorn 조합을 사용한다고 가정할 때, uvicorn은 fastapi 웹 애플리케이션을 하나의 프로세스마다 하나의 메인 스레드로 운영한다. 또한 python은 스레드 하나에 이벤트 루프 하나라는 기준이 있기에 결론적으로 하나의 fastapi + uvicorn 프로세스 조합에 하나의 이벤트 루프가 모든 작업을 수행한다.

그렇다면 `def`로 정의된 동기 핸들러 함수는 어떻게 처리될까? fastapi는 동기 함수를 위한 스레드 풀도 미리 준비한다. 스레드 풀은 기본적으로 40개의 스레드를 준비하며 이는 수정이 가능하다. 결국 이벤트 루프가 아닌 별도로 준비된 스레드에 의해 실행되는 방식이다.

## 의존성 주입

fastapi는 router 함수의 매개변수로 전달하는 방식으로 의존성을 주입해주는 기능을 제공한다. 의존성은 별도의 주입 함수를 정의하고 함수의 반환 값이 주입되는 원리이다.

기본적으로 요청 단위의 캐시를 기반으로 동작한다.

하나의 HTTP 요청을 처리하는 과정에서 여러 의존성이 동일한 하위 의존성을 공유하는 경우, fastapi는 이를 한 번만 실행한다. 첫 번째 의존성이 호출되어 하위 의존성의 결과값을 얻으면, 그 결과는 해당 요청의 캐시에 저장된다. 이후 같은 요청 내에서 해당 의존성이 다시 필요할 때는 캐시된 값을 재사용한다.

구체적인 실행 순서는 다음과 같다. 함수 시그니처에 정의된 순서대로 의존성이 호출된다. 예를 들어 call_a와 call_b가 모두 dependency라는 하위 의존성을 가지면, call_a가 먼저 호출되어 dependency를 실행하고 결과를 캐시에 저장하면, 나중에 호출된 call_b는 캐시에서 해당 값을 가져온다.

그리고 의존성 주입 함수 또한 sync/async를 구분하며, 핸들링 함수와 동일한 원리로 실행된다.

## 데이터 유효성 검증

pydantic 혹은 python의 @dataclass를 활용한 데이터 유효성 검사 기능도 제공한다. 이는 어떻게 동작하는가?

먼저 입력 데이터가 들어오면, 함수의 시그니처를 확인한다. 전달된 데이터가 정의된 클래스 모델의 각 속성 타입과 일치하는지 검사한다. 이 과정에서 데이터가 모델 규격과 일치하지 않으면, 즉시 422 에러를 클라이언트에 반환한다. 해당 에러 응답은 개발자가 오버라이드하여 재구성이 가능하다.

입력 데이터 검증을 통과하면, 검증된 데이터를 python의 객체 형태로 라우터 함수에 전달하여 비즈니스 로직을 수행한다.

비즈니스 로직 수행 후 반환된 결과값 또한 검증 대상이 될 수 있다. @router 내부에 response_model 속성 값을 특정 클래스 모델로 정의하면, 결과 데이터가 해당 모델 규격과 일치하는지 검사한다. 만약 여기서 검증에 실패하면, 이는 서버의 문제로 인식되어 500 에러를 클라이언트에 내보낸다. 이는 의도치 않은 데이터 유출 방지를 위함이다.

또한 데이터 유효성 검증을 수행하기도 하지만 모델 클래스 내부의 로직에 따라 문자열로 들어온 날짜를 datetime 객체로 변환하거나, 문자열로된 숫자를 int 타입으로 캐스팅하는 기능도 있다.

## 서버 스케일링 및 배포

uvicorn + fastapi 조합의 서버를 배포할 때, 과거에는 앞 단에 gunicorn을 추가시켜 uvicorn 프로세스들을 관리하는 방식이 권장되었다. 왜냐하면 uvicorn도 다중 프로세스 관리 기능이 존재하나, 기능에 대한 성숙성이나 세부 설정 기능이 부족하였기 때문이다.

하지만 최근에는 gunicorn 대신에 쿠버네티스를 결합하여, 단일 uvicorn 워커 프로세스에 대한 각 파드를 관리하는 방식으로 많이 배포된다. 또한 uvicorn이 점점 성장하면서 자체적인 프로세스 관리 기능의 강화로 gunicorn 없이도 프로세스 관리가 가능할 것으로 보인다.