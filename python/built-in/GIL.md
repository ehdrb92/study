## GIL 배경

Python은 메모리 관리를 위해 참조 카운팅 방식을 사용한다. Python에서 생성된 객체는 해당 객체를 가리키는 참조의 수를 추적하는 참조 카운트 변수를 가지고 있다. 이 카운트가 0이 되면 객체가 차지하는 메모리가 해제된다.

핵심 문제는 멀티 스레딩 환경에서의 경쟁 상태이다. 동시에 값을 증가시키거나 감소시키는 두 스레드가 특정 객체에 대해 경쟁 상태에 있을 때 보호가 필요하게 되었다. 경쟁 상태에 있는 객체의 참조 카운트가 잘못 기록되면 메모리에 영구적인 누출 혹은 해당 객체에 참조 카운트가 실제로는 있음에도 잘못 헤제될 수 있다. 이러한 문제를 해결하기 위한 선택지가 있다.

첫 번째로 스레드 간 공유되는 모든 데이터 구조에 락을 추가하여 참조 카운트 변수를 안전하게 유지할 수 있다. 하지만 각 객체나 객체 그룹에 락을 추가하는 것은 다중의 락이 존재하게 되어 데드락 문제를 야기할 수 있다. 또 다른 부작용으로는 락의 반복적인 획득과 헤제로 인한 성능 저하이다.

두 번째 방식인 GIL은 인터프리터 자체에 대한 단일 락으로, Python 바이트코드의 실행이 인터프레터 락을 획득 요구해야한다는 규칙을 추가한 것이다. 이는 데드락을 방지하고 많은 성능 오버헤드를 일으키지 않을 수 있다. 하지만 실질적으로 Python 프로그램을 단일 스레드로 만들어 버린다.


## GIL이 멀티 스레딩에 미치는 영향

일반적으로 Python 프로그램에서 CPU-bound인 것과 I/O-bound인 것 사이에 미치는 영향의 차이가 있다.

CPU-bound 프로세스의 경우 단일 스레드와 멀티 스레드 버전을 비교했을 때 성능 결과가 동일하거나 오히려 멀티 스레드에서 낮아지는 결과가 생긴다. 이는 스레드가 많더라도 GIL이 스레드의 병렬 실행을 막아버리기 때문이다. 또한 단일 스레드가 계속해서 프로세스를 수행하지않고 오히려 다중의 스레드가 교체되면서 프로세스를 수행하는 과정에서 락의 획득과 헤제에 발생하는 오버헤드가 오히려 멀티 스레드 성능을 저하시킨다.

I/O-bound 프로세스는 상황이 다르다. 스레드가 I/O 작업을 기다리는 상황이 되면 GIL이 헤제되고 다른 스레드가 실행되어 작업을 수행하게 된다. I/O를 기다리는 유휴 시간에 다른 스레드가 락을 획득하여 작업을 수행하기 때문에 성능에 큰 영향을 일으키지 않는다.


## Python3에서 GIL 개선사항

일부 스레드는 I/O-bound이고 일부는 CPU-bound인 프로그램에서, Python의 GIL은 CPU-bound 스레드로부터 GIL을 획득할 기회를 주지 않아 I/O-bound 스레드들을 굶주리게 하는 것으로 알려져 있었다.

이는 Python에 내장된 메커니즘 때문이었는데, 이 메커니즘은 스레드들이 고정된 간격의 연속 사용 후에 GIL을 해제하도록 강제했고, 다른 누구도 GIL을 획득하지 않으면 같은 스레드가 계속 사용할 수 있었다.

이 문제는 2009년 Python 3.2에서 Antoine Pitrou에 의해 수정되었다. 그는 다른 스레드들에 의해 삭제된 GIL 획득 요청의 수를 살펴보고, 다른 스레드들이 실행될 기회를 얻기 전에 현재 스레드가 GIL을 재획득하는 것을 허용하지 않는 메커니즘을 추가했다.


## GIL 문제에 대한 대처방법

- 멀티 프로세싱
    가장 인기 있는 방법은 스레드 대신 여러 프로세스를 사용하는 멀티프로세싱 접근법을 사용하는 것이다. 각 Python 프로세스는 자신만의 Python 인터프리터와 메모리 공간을 갖기 때문에 GIL이 문제가 되지 않는다. 하지만 프로세스 관리에 자체적인 오버헤드가 있을 수 있다. 여러 프로세스는 여러 스레드보다 무겁기 때문에, 이것이 확장성 병목이 될 수 있다는 점을 염두에 두어야한다.
- 대안적 Python 인터프리터 사용
    Python은 여러 인터프리터 구현체를 가지고 있다. 각각 C, Java, C#, Python으로 작성된 CPython, Jython, IronPython, PyPy가 가장 인기 있는 것들이다. GIL은 원래 Python 구현체인 CPython에만 존재한다. 라이브러리와 함께 프로그램이 다른 구현체 중 하나에서 사용 가능하다면 그것들도 시도해볼 수 있다.


## GIL의 좀 더 상세한 내부

GIL은 정확하게 파이썬 바이트코드를 감싸는 큰 뮤텍스이다. CPython 인터프리터 내부의 바이트코드 실행 루프를 잠그는 것이다. 파이썬 객체의 참조 카운팅과 여러 내부 구조가 스레드 안전하지 않기 때문에 파이썬 레벨 코드를 실행하는 동안에는 GIL을 반드시 보유해야한다.

일반적으로 GIL이 헤제 혹은 넘겨지는 순간은 다음과 같다.

- OS 레벨에서 스케줄링 간격(기본 수 ms; sys.setswitchinterval()로 조정)마다 현재 스레드가 다른 스레드에게 GIL을 양보할 수 있다.
- 블로킹 입출력 호출을 만날 때는 CPython이 GIL 잠금을 헤제한다. 입출력 작업이 끝나면 다시 GIL을 해당 스레드가 획득하거나, 헤제되었을 때 다른 스레드가 획득할 수 있다.
- C 확장 코드가 명시적으로 Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS 매크로로 GIL을 풀 수도 있다(NumPy 같은 라이브러리가 긴 연산에서 종종 사용).