SQLAlchemy의 세션 객체는 상황에 따라 다른 상태로 존재한다.

- Transient (비영속)
  - 세션에 속하지 않았으며 데이터베이스에 저장된 적이 없는 상태
  - Python 메모리에만 존재하는 객체로, 데이터베이스 식별자(Primary Key)가 없다.
- Pending (대기)
  - `session.add()` 를 통해 세션에 추가되었으나, 아직 데이터베이스에 실제로 `INSERT` 되지 않은 상태
  - 다음 플러시가 발생할 때 데이터베이스에 기록될 예정이다.
- Persistent (영속)
  - 세션에 포함되어 있으며, 데이터베이스에 해당 레코드가 존재하는 상태이다.
  - 데이터베이스에서 쿼리하여 가져온 객체이거나, `Pending` 객체가 플러시되어 데이터베이스 식별자를 얻은 상태이다.
- Deleted (삭제)
  - 세션 내에서 삭제(`session.delete()`)되었고 플러시까지 수행되었으나, 아직 트랜잭션이 커밋되지는 않은 상태이다.
  - 커밋하면 영구적으로 삭제되고, 롤백하면 다시 영속 상태가 된다.
- Detached (분리)
  - 데이터베이스 식별자는 가지고 있지만, 현재 어떠한 세션과도 연결되지 않은 상태이다.
  - 세션이 닫히거나, 명시적으로 세션에서 제거(`expunge`)되었을 때 발생한다. 이 상태의 객체는 지연 로딩을 사용할 수 없다.

## 세션 주요 생애주기 메서드

- add: 비영속 객체를 대기 상태로 만든다.
- flush: 메모리의 변경 사항을 데이터베이스 트랜잭션 버퍼로 전송한다. 이 과정에서 SQL이 실제로 실행되지만, 아직 트랜잭션이 커밋된 것은 아니다. 플러시를 통해 영속 상태가 될 수 있다.
- commit: 커밋은 `flush + commit` 역할을 수행한다. 변경 사항을 데이터베이스에 영구적으로 반영하고, 트랜잭션을 종료한다.
  - 커밋이 완료되면, 기본적으로 세션 내의 모든 객체는 만료(expire) 처리 된다. 즉, 객체의 속성 데이터가 지워지며, 다음 번에 해당 객체에 접근할 때 데이터베이스에서 다시 로드한다. 이는 새로운 트랜잭견 시작 시 데이터 정합성을 맞추기 위해서이다.
- rollback: 트랜잭션을 취소한다. 대기 상태였던 객체는 비영속 상태로 돌아가고, 삭제된 객체는 영속 상태로 돌아간다.
- expire: 객체의 속성을 오래된 것으로 만든다. 실제 데이터베이스 SQL은 발생하지 않으며, 나중에 해당 객체의 속성에 접근할 때 쿼리가 실행되어 데이터를 갱신한다.
- refresh: 즉시 SELECT SQL을 실행하여 객체의 내용을 데이터베이스 최신 값으로 업데이트한다.
- merge: 세션 외부에 있는 객체의 데이터를 세션 내부의 새로운 또는 기존 객체로 복사해 넣는다.

## 세션 생애주기의 비유

쇼핑몰에서 물건을 사오는 과정에서 세션을 쇼핑 카트로, 집과 쇼핑몰을 데이터베이스로 비유한 것이다.

1. 비영속: 세션은 집에서 구매할 목록(객체 목록)을 적어 놓은 체크리스트와 같다.
2. 대기: 쇼핑몰에서 물건을 집어 카트(세션)에 담은 상태이다.
3. 영속: 계산대에 물건을 올려놓고 시스템이 찍혔지만(플러시, INSERT), 다음으로 결제(커밋)를 한다.
4. 분리: 물건을 가지고 집으로 돌아온 상태이다. 더 이상 카트(세션) 안에는 객체가 없지만, 물건을 집에 실재한다.
