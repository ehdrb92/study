DBMS(Database Management System)의 경우 종류에 따라 다르지만 일반적으로 다음의 요소들이 존재한다.

- 쿼리 평가 엔진
- 접근 메서드
- 동시 실행 제러
  - 트랜잭션 매니저
  - 락 매니저
- 리커버리 매니저
- 버퍼 매니저
- 디스크 용량 매니저
- 데이터 베이스

쿼리 평가 엔진은 사용자로부터 입력받은 SQL 구문을 분석하소, 어떤 순서로 기억장치의 데이터에 접근할 지를 결정한다. **실행 계획**을 세우는 것이다. 실행 계획에 기반을 둬서 데이터에 접근하는 방식을 **접근 메서드**라고 한다.

버퍼는 특별한 용도로 사용되는 메모리 영역이다. 이 메모리 영역을 관리하는게 버퍼 매니저이다. 이는 디스크 용량 매니저와 함께 연동되어 작동한다.

디스크 용량 매니저는 어디에 어떻게 데이터를 저정할지 관리하며, 데이터의 읽고 쓰기를 제어한다.

DBMS는 둘 이상의 SQL 실행을 하나의 작업으로 묶어 단위로 관리한다. 여기서 이 작업 단위를 트랜잭션이라고한다. 또한 특정 데이터 단위로 락을 걸어서 특정 트랜잭션이 해당 데이터에 대한 작업을 수행 중일때 다른 트랜잭션이 접근하는 것을 막을 수 있다. 이들을 관리하는게, 트랜잭션 매니저와 락 매니저이다.

데이터베이스에 중요한 데이터들을 정기적으로 백업하고, 문제가 일어났을 때 복구해줘야 하는데, 이 기능을 수행하는게 리커버리 매니저이다.

## DBMS와 기억장치의 관계

- 디스크: 대부분의 데이터가 저장되는 매체이다. 용량, 비용, 성능의 관점에서 크게 좋지는 않지만, 나쁜점도 없는 장치이다.
- 메모리: 디스크 대비 성능은 좋지만, 기억 비용이 굉장히 비싸다.
- 버퍼: 여기서 말하는 버퍼는 일반적으로 메모리이다. 메모리는 영속적인 저장이 불가능하다는 점과 공간이 작다라는 단점이 있어서 메인 저장 매체로 사용하기가 어렵기 때문에 버퍼(혹은 캐시)로서 활용된다. DBMS가 데이터 작업에서 매번 디스크에 직접 접근하면 병목이 심하기에 중간 매체로 메모리를 활용한다.

## 메모리에 존재하는 두 개의 버퍼

DBMS가 데이터 유지를 위해 일반적으로 사용하는 버퍼는 크게 두 종류이다.

- 데이터 캐시
- 로그 버퍼

데이터 캐시는 디스크에 있는 일부 데이터를 메모리에 유지시키는 영역이다. 실행한 SELECT 구문의 데이터가 데이터 캐시에 존재한다면, 굉장히 빠른 처리가 가능하다.

DBMS는 갱신 처리(INSERT, DELETE, UPDATE, MERGE)와 관련된 SQL을 받으면, 이를 곧바로 저장소의 데이터 처리에 사용하지 않는다. 일단 로그 버퍼에 변경 정보를 보내고 이후 데이터 변경을 수행한다. 이러한 시점차이를 두는 이유는 성능 때문이다. 갱신 작업은 조회 작업 못지않게 상당한 시간이 소요될 수 있기에, 사용자가 SQL을 실행하면, 사용자에게는 수행되었다고 결과를 통지하고, 내부적으로 계속해서 해당 작업을 수행하는 비동기 방식으로 동작한다.

일반적으로는 데이터의 갱신 대비 조회 작업이 많기 때문에 데이터 캐시의 용량이 로그 버퍼에 비해 크다. 하지만 현대적인 DBMS에서는 둘의 용량을 조절이 가능하다.

## 추가적인 메모리 여역인 워킹 메모리

조회 작업에서 정렬, 집합 연산, 윈도우 함수 등의 기능을 사용할 때 사용하는 워킹 메모리 영역이 존재한다. 해당 영역은 DBMS의 종류마다 부르는 이름이 다르다. PostgreSQL은 워크 버퍼라고 부른다. 앞서 말한 작업이 실행할 때 사용되었다가 끝나면 바로 정리되는 임시 영역이다. 이 영역의 경우 작업하려는 데이터의 양이 영역의 크기보다 크면, 디스크 영역을 사용하기 때문에 OS 수준에서 스왑을 하게된다. 그러면 작업 속도가 현저히 느려질 수 있다. 작업 자체는 수행된다.

## DBMS가 SQL을 받아서 접근하는 방법을 수립하는 과정

보통은 다음과 같은 순서로 모듈이 실행된다.

1. 파서(parser)
2. 옵티마이저(optimizer)
3. 카탈로그 매니저(catalog manager)
4. 플랜 평가(plan evaluation)

파서는 수집한 SQL 구문의 문법(?)을 분석하는 것이다. 사용자로부터 입력받은 SQL 구문이 올바르다는 보증이 없다. 그렇기에 이를 평가해서 올바른 문법으로 쓰였는지 확인하고, 아닐경우 에러를 발생시키는 것이다. 일반적인 프로그래밍 언어의 컴파일러가 문법 검사를 하는 것과 유사하다.

옵티마이저는 최적화를 수행한다. 실행 계획을 수립하는 핵심적인 역할을 한다. 인덱스 유무, 데이터 분산 또는 편향 정도, 내부 매개변수 등의 조건을 ㄱ고려해서, 선택 가능한 많은 실행 계획을 작성하고, 이들의 비용을 계산하며, 가능 낮은 비용의 계획을 선택한다.

카탈로그 매니저는 옵티마이저가 실행 계획을 세울 때 중요란 정보를 제공하는 역할을 한다. 카탈로그란 DBMS의 내부 정보를 모아놓은 테이블들로, 테이블 또는 인덱스의 통계 정보가 저장되어 있다. 그래서 카탈로그를 간단하게 **통계 정보**라고 부르기도 한다.

플랜 평가는 옵티마이저가 세운 실행 계획 중 최적의 계획을 선택하는 것이다. 사실 실행 계획 자체는 곧바로 DBMS가 실행할 수 있는 형태의 코드가 아니다. 일종의 계획서일 뿐이다. 실행 계획이 선택되면, 이후에 DBMS가 이를 절차적인 코드로 변환한다.

일반적으로 카탈로그에 포함된 정보는 다음과 같은 것이 있다.

- 각 테이블의 레코드 수
- 각 테이블의 필드 수와 필드의 크기
- 필드의 카디널리티(cardinality)
- 필드값의 히스토그램(어떤 값이 얼마나 분표되어 있는가)
- 필드 내부의 있는 NULL의 수
- 인덱스 정보

카탈로그와 관련해서 문제가 생기는 경우가 존재한다. 카탈로그 정보가 실제 테이블 또는 인덱스와 일치하지 않는 경우이다. 테이블에 데이터 갱신 작업이 수행되었는데, 카탈로그 갱신이 함께 되지 않으면, 옵티마이저는 잘못된 정보를 바탕으로 계획을 수립한다. 극단적인 경우에는 단번에 많은 수의 레코드가 갱신되었는데, 잘못된 정보로 계획을 세워서 성능이 나빠질 수 있다.

그렇다면, 데이터를 갱신할 때마다 카탈로그 갱신하면 안되는가? 사실 카탈로그 갱신도 실행 비용이 굉장히 높은 작업이다. 올바른 계획 수립을 위해서 카탈로그의 갱신을 자주하면 좋지만, 카탈로그 갱신이 오히려 다른 측면에서 성능에 방해를 할 수 있다.