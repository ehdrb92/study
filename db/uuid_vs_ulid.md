UUID(Universally Unique Identifiers)와 ULID(Universally Unique Lexicographically Sortable Identifier)를 비교하고 각각 어떤 상황에서 사용해야할지 비교해보자.


## UUID

uuid는 무작위성과 유일성의 특성을 가진 128비트로 이루어진 식별자이다. python에서는 표준 라이브러리로 값을 생성하는 함수를 제공한다.

uuid는 다음과 같은 한계점을 가진다.

- 데이터베이스의 성능: uuid를 테이블의 기본 키로 사용한다고 가정하자. uuid는 생성될 때마다 규칙성이 전혀 없는 무작위의 값을 생성해낸다. 그렇기 때문에 데이터가 삽입될 때마다 기본 키의 인덱스로 사용되는 B+tree 구조의 리밸런싱을 유도한다.
- 저장 용량: 하나의 uuid가 차지하는 128비트 즉 16바이트는 일반적으로 많이 사용되는 int 혹은 bigint에 비해 너무 많은 공간을 차지한다.
- 정렬 불가: uuid는 무작위의 값이기 때문에 기본적으로 정렬이 의미가 없다. 이는 데이터베이스에 특정 범위 값에 대한 쿼리 대상이 uuid 일때 성능 문제를 유발할 수 있다.


## ULID

ulid는 uuid의 제한적인 사항을 해결하면서, uuid 시스템과의 호환성을 유지시키는 것을 목표로 한다. ulid 또한 uuid와 마찬가지로 128비트의 길이를 가지지만 구조적으로 다르다.

- 첫 48비트의 값은 타임스탬프을 표현(millisecond 정밀도)
- 남은 80비트는 무작위로 생성된 값

위와 같은 구조로 생성된 ulid는 다음과 같은 이점을 준다.

- 정렬: 타임스탬프 구성을 포함하기 때문에 사전순으로 정렬이 가능하다.
- 단조 증가: 타임스탬프 구성으로 인해 일반적으로 시간이 지남에 따라 증가하는 의미를 가질 수 있다.
- uuid와 호환: 같은 128비트인 ulid는 기존에 uuid에 맞추어져 사용되는 시스템에서 uuid를 대체할 수 있다.


## 언제 대체해야 할까?


- 데이터베이스 시스템이 ulid를 기본적으로 지원하는지, 아니면 문자열이나 바이너리 데이터로 처리해야 하는지 확인이 필요하다. 문자열이나 바이너리로 처리한다면, 오히려 더 많은 데이터 공간 낭비가 유발될 수 있다.
- 만약 ORM을 사용한다면 ulid와 원활하게 작동하기 위해 사용자 정의 필드 혹은 변환기가 필요할 수 있다.
- 이미 uuid를 사용하는 시스템인지 확인한다. uuid는 쉽게 대체가 가능하나, 아니라면 다른 선택지를 고려해야한다.
- ulid에는 타임스탬프가 포함되기 때문에 데이터 프라이버시가 중요하다면 적합하지 않을 수 있다.
- uuid는 이미 python의 표준 라이브러리이지만, ulid는 제 3자 라이브러리이다. 중요한 프로젝트에 반영하기 전에 ulid 라이브러리의 성숙도와 유지보수 상태 확인이 먼저 필요하다.


## 추가 설명

- uuid의 무작위 성이 어떻게 인덱스 리밸런싱에 영향을 주는가?
    일반적으로 순서가 정해져 들어가는 데이터의 경우 데이터 삽입 시 인덱스의 가장 마지막에 추가되기 때문에 별도의 리밸런싱 소모값이 없다. 하지만, 데이터가 중간에 어떤 부분에 추가된다면, B+tree의 페이지 분할이 잦아지고, 캐시 히트율이 떨어지며 쓰기 성능 및 검색 성능 모두 악화될 수 있다.
- varchar 타입 데이터를 36자 길이 제한으로 저장하는 것과 uuid 타입으로 저장하는 것에 차이점은 무엇인가?
    postgresql의 경우 기본적으로 uuid 타입을 지원한다. 해당 데이터를 문자열로 저장하지 않고, 내부적으로 128비트의 바이너리 형태로 저장하게 된다. 그렇기 때문에 기본적으로 36글자 크기의 문자열에 비해 저장 공간이 작다. 그리고 uuid를 varchar 타입으로 저장한다면 문자 인코딩, 정렬 및 비교 시 추가 오버헤드 발생 가능성이 있다. 저장 공간이 크기에 인덱스 크기도 증가하고, 디스코 입출력 및 메모리 캐시 효율 등이 떨어질 수 있다.

    postgresql uuid vs text: https://www.jacoelho.com/blog/2021/06/postgresql-uuid-vs-text/?utm_source=chatgpt.com
    postgresql varchar(36) vs uuid: https://aws.amazon.com/ko/blogs/database/getting-more-with-postgresql-purpose-built-data-types/?utm_source=chatgpt.com
    https://stackoverflow.com/questions/32189129/performance-difference-between-uuid-char-and-varchar-in-postgresql-table?utm_source=chatgpt.com


## UUIDv1

사실 위에서 설명한 UUID는 구체적으로 UUIDv4이다. UUID에는 이 외에도 다양한 버전이 있는데, 그 중 버전 1에 대한 특징은 다음과 같다.

- 생성: 60비트 타임스탬프와 48비트 MAC 주소를 사용한다. 클럭 조정 및 MAC 주소를 사용할 수 없을 때 고유성 보장을 위한 클럭 시퀀스 필드가 추가된다.
- 시간 순서: 타임스탬프 영향으로 일반적으로 나중에 생성된 값이 이전에 생성된 값보다 수치적 크다. 이 속성은 데이터베이스에 새로운 데이터 삽입 시 순차적으로 추가되어 페이지 분할을 줄이고, 블록 캐싱을 개선하므로 b+tree 인덱스에 유리하다.
- 전역 고유성: 타임스탬프와 MAC 주소의 조합으로 고유해진다.
- 정보 노출: 생성된 머신의 MAC 주소를 노출하기 때문에, 이는 개인 정보 보호 문제가 될 수 있다.
- 이식성 문제: MAC 주소에 의존하는 것은 MAC 주소가 변경되거나 무작위화될 수 있는 가상화 또는 클라우드 환경에서 문제가 될 수 있다.


## UUIDv7

UUIDv7은 RFC 9562에 정의된 표준으로, 시간 정렬성과 무작위성을 결합하여 v1 및 v4의 단점을 해결하는 것을 목표로 한다.

- 생성: 48비트 Unix epoch 타임스탬프(밀리초 단위)로 시작하며, 버전 및 변형을 위한 12비트, 그리고 62비트의 의사 무작위 데이터가 이어집니다. 이 시간 구성 요소는 자연스럽게 정렬 가능하게 만듭니다.
- 시간 정렬: 선행 타임스탬프는 새 UUID가 이전 UUID보다 수치적으로 큰 경향이 있도록 보장합니다. 이는 B-트리 인덱스에서 삽입 성능을 크게 향상시키며, 페이지 분할을 최소화하고 좋은 클러스터링 계수를 유지하여 자동 증가 정수와 유사합니다.
- 정보 노출 없음: v1과 달리 MAC 주소를 포함하지 않아 개인 정보를 보호합니다.
- 높은 고유성: 무작위 구성 요소는 강력한 고유성 보장을 제공합니다.
- 데이터베이스 친화적: 특히 데이터베이스 인덱스 성능을 염두에 두고 설계되었습니다.
- 표준화: 신흥 표준이지만, 빠르게 채택되고 있습니다.
