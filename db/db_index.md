## 인덱스란?

데이터베이스의 인덱스는 지정한 컬럼에 대한 목차를 생성하여 조회 성능을 향상시키는 것이다. 하지만 늘 얻는게 있으면 잃는게 있듯이 삽입, 수정, 삭제 쿼리의 성능을 희생해야한다. 여기서 수정과 삭제의 경우 수정과 삭제를 위해 데이터를 찾아가는 과정은 오히려 인덱스에 의해 빨라질 수 있다. 그러니 많은 양의 데이터를 삭제해야하는 상황이라면 WHERE절로 찾아가는 컬럼은 인덱스를 만들면 좋다.

![b-tree](./b-tree.png)

- 인덱스 탐색은 `루트 -> 브랜치 -> 리프 -> 디스크 저장소` 순서로 진행된다.
  - 인덱스 각 페이지에는 dept_no, emp_no, 자식 페이지 주소로 이루어진다.
  - 위 이미지에서는 dept_no=d001 and emp_no=10018로 조회하면 이에 대한 데이터 주소를 4번 페이지에서 찾게된다.
- 복합 인덱스의 경우 n번째 컬럼은 n-1번째 컬럼에 의존해서 정려된다.
  - 즉, 두 번째 컬럼은 첫 번째 컬럼이 똑같은 열에서만 의미가 있다.
- 디스크에서 읽는 것은 메모리에서 읽는 것보다 성능이 크게 떨어진다.
  - 인덱스의 성능을 향상시킨다는 것은 디스크 저장소에 얼마나 덜 접근하게 하는가, 인덱스 루트에서 리프까지 오고가는 획수를 얼마나 줄이느냐에 달려있다.
- 인덱스의 갯수는 3 ~ 4개가 적당하다.
  - 너무 많은 인덱스는 수정, 삭제 작업에 큰 성능 이슈를 가져올 수 있다.
  - 인덱스 역시 공간을 차지하기 때문에 너무 많으면 자원을 많이 소모한다.
  - 인덱스가 너무 많으면 옵티마이저가 잘못된 선택을 할 수 있다.

## 인덱스 키 값의 크기

인덱스 역시 페이지 단위로 관리된다. 페이지의 크기는 16KB(MySQL 기준)로 고정되어 있다. 만약 여기서 키에 해당하는 컬럼의 값이 작으면 페이지에서 키가 차지하는 용량이 적기 때문에 트리의 깊이가 얕아져 찾아가는 비용도 적어지지만 키가 차지하는 용량이 커지면 그 만큼 하나의 페이지에 넣을 수 있는 인덱스 데이터가 적어지고 트리 깊이도 깊어질 수 밖에 없다.

## 인덱스 컬럼 기준

인덱스로 설정할 컬럼은 카디널리티(Cardinality)가 가장 높은 것을 선택해야한다. 카디널리티란 해당 컬럼의 중복된 수치를 나타낸다.

예를들어 성별, 학년 등은 같은 값이 여러 개의 데이터에 분포될 수 있다. 이러한 데이터는 카디널리티가 낮다. 대신 주민등록번호, 계좌번호와 같은 유일한 데이터는 카디널리티가 높다.

그리고 만약 2개의 컬럼으로 복합 인덱스를 사용했다고 하자. 이때 복합 인덱스의 첫 번째와 두 번째 모두를 조건에 사용할 때 첫 번째 조건에 해당하는 값이 조건을 만족하지 못하면 두 번째 인덱스의 값에 대한 조회는 인덱스를 전혀 활용하지 못한다.

## 참조

https://jojoldu.tistory.com/243