prisma orm에서 연관 관계 데이터의 조회하는 방법은 두 가지이다. include 혹은 select 속성을 내부적으로 사용하면 된다. 만약 user, post 테이블이 존재하고 post가 user 테이블을 참조한다면, 다음과 같은 예시를 사용할 수 있다.

```js
const users = await prisma.user.findMany({
  relationLoadStrategy: 'join', // or 'query'
  include: {
    posts: true,
  },
})

const users = await prisma.user.findMany({
  relationLoadStrategy: 'join', // or 'query'
  select: {
    posts: true,
  },
})
```

relationLoadStrategy 속성의 값에 join, query 둘 중 특정 전략을 사용하면된다. 만약 지정하지 않으면 기본값으로 join 전략으로 채택된다.

먼저 join 전략은 PostgreSQL의 경우 `LATERAL JOIN`과 `JSON aggregation`을 사용한다. 데이터베이스 서버에서 직접 JSON 구조를 생성하여 애플리케이션 서버의 변환 부담을 줄이는 방식이다. 결국 단일 SQL을 통해 모두 한번에 가져오는 것이다.

다음으로 query 전략의 경우 애플리케이션 수준에서 조인을 수행하는 방식으로, 여러 개의 SQL 쿼리를 각각 실행한다.

주 테이블을 조회하는 쿼리를 먼저 보낸 후, 결과로 얻은 ID 값을 가지고 연관된 테이블들을 별도로 조회한다. 이후 Prisma 클라이언트 내에서 이 데이터들을 병합한다. 이 방법은 데이터베이스 서버의 부하를 줄이지만, 데이터 병합을 CPU에서 수행해야하며, 데이터베이스 통신 횟수가 늘어난다.

다음은 각 전략별 실제 SQL 예시이다.

가정하는 관계는 다음과 같다.

- User (주 테이블)
- Profile (User와 1:1 관계)
- Post (User와 1:N 관계)
- Category (Post와 N:M 관계 - 중간 테이블 존재)

```js
const users = await prisma.user.findMany({
  relationLoadStrategy: 'join', // 또는 'query'
  include: {
    profile: true,      // 1:1
    posts: {            // 1:N
      include: {
        categories: true // N:M (참조의 참조)
      }
    }
  }
});
```

먼저 join 전략이다.

```sql
SELECT 
  "public"."User"."id", 
  "public"."User"."email",
  -- 1:1 관계 (Profile)를 JSON 객체로 가져옴
  "subquery_profile"."profile_json" AS "profile",
  -- 1:N 및 N:M 관계 (Posts + Categories)를 JSON 배열로 집계
  "subquery_posts"."posts_json" AS "posts"
FROM "public"."User"
LEFT JOIN LATERAL (
  SELECT to_jsonb("public"."Profile".*) AS "profile_json"
  FROM "public"."Profile"
  WHERE "public"."Profile"."userId" = "public"."User"."id"
) AS "subquery_profile" ON TRUE
LEFT JOIN LATERAL (
  SELECT json_agg(obj) AS "posts_json"
  FROM (
    SELECT 
      "public"."Post".*,
      -- 중첩된 N:M 관계 (Categories) 처리
      (SELECT json_agg("public"."Category".*)
       FROM "public"."Category"
       INNER JOIN "public"."_CategoryToPost" ON "public"."Category"."id" = "public"."_CategoryToPost"."A"
       WHERE "public"."_CategoryToPost"."B" = "public"."Post"."id"
      ) AS "categories"
    FROM "public"."Post"
    WHERE "public"."Post"."authorId" = "public"."User"."id"
  ) AS obj
) AS "subquery_posts" ON TRUE;
```

다음은 query 전략이다.

```sql
SELECT * FROM "User";
SELECT * FROM "Profile" WHERE "userId" IN (1, 2, 3, ...); -- User ID 리스트 사용
SELECT * FROM "Post" WHERE "authorId" IN (1, 2, 3, ...);
-- 3번에서 가져온 Post ID들을 사용하여 카테고리와 중간 테이블 조인 조회
SELECT "C".*, "Join"."B" AS "postId"
FROM "Category" "C"
INNER JOIN "_CategoryToPost" "Join" ON "C"."id" = "Join"."A"
WHERE "Join"."B" IN (101, 102, 103, ...); -- Post ID 리스트
```

결론적으로 각 전략의 선택 기준은 간단히 다음과 같다.

- join: 대부분의 일반적인 상황
- query: 불러오는 데이터의 양이 너무 방대하여 데이터베이스 CPU 부하를 분산해야할 때
  - 일반적으로 애플리케이션 서버에 비해 데이터베이스의 수평확장은 고려해야할 부분이 많다. 그래서 데이터베이스 서버의 부하를 상대적으로 수평확장이 용이한 애플리케이션 서버로 주어서 부하를 분산시킬 수 있다.