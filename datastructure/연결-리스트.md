연결 리스트는 각 노드들이 서로 연결된 리스트라고 할 수 있다. 각 노드는 자신의 데이터와 연결된 노드의 주소인 포인터를 가진다. 포인터에 기재된 주소를 따라가면, 다른 노드의 데이터로 이어진다.

기본적으로 대부분의 프로그래밍 언어에 내장된 배열과 달리 연결 리스트는 직접 구현해야한다. 이전 혹은 다음 노드의 주소를 몰라도 되는 배열과 차이가 있다. 둘을 비교하면 다음과 같다.

- 배열은 프로그래밍 언어에 내장되어있지만, 연결 리스트는 그렇지 않다.
- 배열은 고정된 크기의 메모리를 차지하지만, 연결 리스트는 동적이다.
- 배열은 각 요소 혹은 노드의 메모리 주소가 인접해 있지만, 연결 리스트는 그렇지 않다.
- 배열에 비해 연결 리스트는 포인터의 존재로 메모리를 더 많이 사용한다.
- 배열은 특정 요소 혹은 노드에 직접 접근이 가능하지만, 연결 리스트는 처음부터 순차적으로 접근해야한다.
- 연결리스트는 삽입 혹은 삭제에 상수의 시간 복잡도를 가지지만, 배열은 요소 혹은 노드의 이동이 필요하여 그렇지 않다.

연결 리스트는 다음의 종류가 있다.

- 싱글 연결 리스트: 노드는 데이터와 다음 노드로 가는 포인터를 포함한다. 이전 노드로 되돌아 가지는 못하고, 꼬리 부분의 노드 포인터는 null이다.
- 더블 연결 리스트: 노드는 데이터와 이전, 다음 노드로 가는 두 포인터를 포함한다. 헤드 노드의 이전 노드 포인터와 꼬리 노드의 다음 노드 포인터는 null이다.
- 순환 연결 리스트: 노드는 데이터와 이전, 다음 노드로 가는 두 포인터를 포함할 수 있다. 헤드 노드의 이전 노드 포인터는 꼬리 노드를 가르키며, 꼬리 노드의 다음 노드 포인터는 헤드 노드를 가르킨다.

```python
# 싱글 연결 리스트 구현체
class Node:
    def __init__(self, data):
        self.data = data  # The data stored in this node
        self.next = None  # Reference to the next node, initially None

class LinkedList:
    def __init__(self):
        self.head = None  # The head of the list, initially None for an empty list

    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node  # If the list is empty, the new node becomes the head
            return
        current = self.head
        while current.next:
            current = current.next  # Traverse to the last node
        current.next = new_node  # Link the new node to the end of the list

    def display(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        print(" -> ".join(map(str, elements)) + " -> None")

    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head  # The new node points to the current head
        self.head = new_node  # The new node becomes the new head

    def delete(self, data):
        if self.head is None:
            return

        if self.head.data == data:
            self.head = self.head.next  # If head is the target, update head
            return

        current = self.head
        while current.next and current.next.data != data:
            current = current.next
        
        if current.next:
            current.next = current.next.next # Skip the node to be deleted
```