대부분의 프로그래밍 언어에서는 기본적으로 모듈 간 순환 임포트를 금지한다. 금지 이유는 무엇인가?

이는 컴퓨터의 동작 원리에 기반한 근본적인 문제라고 한다.

## 모듈 로딩의 기본 원리

프로그래밍 언어에서 모듈/패키지를 로딩할 때:
```
1. 모듈 파일 읽기
2. 코드 파싱 (구문 분석)
3. 의존성 해결 (다른 모듈 로딩)
4. 변수/함수/클래스 정의 실행
5. 모듈 초기화 완료
```

순환 임포트 시 발생하는 문제:
```python
# A.py
from B import something  # 3단계: B 모듈 로딩 시작
class ClassA: pass       # 4단계: 아직 실행 안됨

# B.py  
from A import ClassA     # 3단계: A 모듈 로딩 시작 (하지만 A는 아직 로딩 중)
class ClassB: pass
```

A → B → A 순서로 로딩하려 하면 A가 완전히 로딩되지 않은 상태에서 A의 내용을 참조하려 해서 문제가 발생

## 컴퓨터 시스템 관점에서의 제약

1. 메모리 로딩 순서
```
RAM 상태:
┌─────────────────┐
│ Module A (로딩중) │ ← 아직 ClassA 정의 안됨
├─────────────────┤
│ Module B (로딩중) │ ← ClassA를 찾으려 하지만 없음
└─────────────────┘
```

2. 심볼 테이블 구성
```
A.py의 심볼 테이블:
┌──────────────┐
│ ClassA: ???  │ ← 아직 정의되지 않음
└──────────────┘

B.py에서 A.ClassA 참조 시도 → 심볼 테이블에 없음 → 에러
```

## 왜 컴퓨터는 순환 임포트를 해결할 수 없을까?

1. 의존성 그래프 이론
순환 임포트는 방향성 그래프의 순환(cycle) 문제이다.
```
A → B → C → A  (순환)
```
이는 **위상 정렬(topological sorting)**이 불가능한 상태이다. 컴퓨터는 "어떤 것을 먼저 로딩해야 할지" 결정할 수 없다.

2. 메모리 할당 순서
```
순환 참조 시:
A가 B를 참조하려면 → B가 먼저 메모리에 있어야 함
B가 A를 참조하려면 → A가 먼저 메모리에 있어야 함
```
위는 논리적으로 모순이다.

3. 컴파일/인터프리터 제약
```
컴파일러/인터프리터 처리 순서:
1. 소스 코드 읽기
2. 구문 분석 (parsing)
3. 의존성 해결
4. 코드 생성/실행

3단계에서 순환 의존성이 발견되면 처리 불가능
```